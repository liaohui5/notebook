## å¿«é€Ÿå¼€å§‹

[canvas](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/canvas) æ˜¯ H5 æ–°å¢åŠ çš„æ ‡ç­¾
æˆ‘ä»¬å¯ä»¥é€šè¿‡ JavaScript Canvas API(2D) æˆ– WebGL API(3D) ç»˜åˆ¶å›¾å½¢åŠå›¾å½¢åŠ¨ç”», ç°é˜¶æ®µä¸»è¦å­¦ä¹  2D ç›¸å…³ API

- [HTMLCanvasElement](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement)
- [CanvasRenderingContext2D](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D)
- [CanvasGradient](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasGradient)
- [CanvasPattern](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasPattern)

::: code-group

```html
<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="no-referrer" />
    <title>Canvas and SVG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        padding: 20px;
      }
      #app {
        border: 1px solid #f00;
      }
    </style>
  </head>
  <body>
    <canvas id="app">Your browser does not support the canvas element.</canvas>
    <script src="./index.js" type="module"></script>
  </body>
</html>
```

```js
window.onload = function () {
  const canvasDom = document.getElementById("app");

  // 2d:   canvas API æ˜¯ CanvasRenderingContext2D ç±»çš„å®ä¾‹
  // webgl: webgl API æ˜¯ WebGLRenderingContext    ç±»çš„å®ä¾‹
  // åŠ ä¸Šæ³¨é‡Šå¯ä»¥è®©ç¼–è¾‘å™¨æ˜¾ç¤ºä»£ç æç¤º
  /** @type {CanvasRenderingContext2D} */
  const ctx = canvasDom.getContext("2d");
  console.log(ctx instanceof CanvasRenderingContext2D); // true

  // è®¾ç½®å®½é«˜å±æ€§
  // æ³¨æ„äº†: è¿™æ˜¯è®¾ç½® canvasDom çš„å±æ€§, è€Œä¸æ˜¯æ ·å¼
  // è¿™ä¸ªdomå¯¹è±¡æ˜¯ HTMLCanvasElement ç±»çš„å®ä¾‹, å®ƒæœ¬èº«å°±æœ‰
  // width å’Œ height å±æ€§, ä½†æ˜¯å®ƒä¸æ˜¯ style çš„å±æ€§
  canvasDom.width = window.innerWidth;
  canvasDom.height = window.clientHeight;
  console.log(ctx.canvas instanceof HTMLCanvasElement); // true
};
```

:::

## å¿«é€Ÿå¼€å§‹:ä½“éªŒç”¨ä»£ç ç”»å›¾

- [moveTo](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/moveTo)
- [lineTo](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineTo)
- [stroke](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/stroke)

```js
window.onload = function () {
  function initCanvasDom() {
    const canvasDom = document.getElementById("app");
    canvasDom.width = window.innerWidth;
    canvasDom.height = window.innerHeight;
    return canvasDom;
  }

  // 0. åˆå§‹åŒ–dom & è·å– canvasä¸Šä¸‹æ–‡
  const canvasDom = initCanvasDom();
  const ctx = canvasDom.getContext("2d");

  // 1.å°† "ç”»ç¬”" æ”¾åˆ°æŒ‡å®šçš„ä½ç½®
  ctx.moveTo(50, 50);

  // 2.ç”¨ "ç”»ç¬”" ç”»ä¸€æ¡çº¿åˆ°æŒ‡å®šçš„ä½ç½®
  ctx.lineTo(100, 50);

  ctx.stroke();
};
```

## æ€è€ƒ ğŸ¤”

> ä¸ºä»€ä¹ˆä¸åº”è¯¥ç”¨ css çš„æ–¹å¼å»è®¾ç½® canvas çš„å®½åº¦å’Œé«˜åº¦

æ³¨æ„æˆ‘è¯´åˆ°çš„æ˜¯ `ä¸åº”è¯¥` è€Œé `ä¸å¯ä»¥`, å®é™…ä¸Šæ˜¯å¯ä»¥é€šè¿‡ css, å»å¼ºè¡Œæ”¹å˜
canvas å…ƒç´ æ˜¾ç¤ºçš„å®½åº¦å’Œé«˜åº¦çš„, æ—¢ç„¶å¯ä»¥æ”¹å˜é‚£ä¸ºä»€ä¹ˆä¸åº”è¯¥ä½¿ç”¨ css è®¾ç½®å®½é«˜å‘¢?
ç©¶å…¶åŸå› : ä¸»è¦æ˜¯å› ä¸º `canvas` å…ƒç´ æœ‰ 2 ä¸ªå°ºå¯¸

1. å†…åœ¨å°ºå¯¸: æˆ–è€…å«ç»˜å›¾çš„ç¼“å†²åŒºå°ºå¯¸, å¯ä»¥é€šè¿‡ `HTMLCanvasElement` ç±»çš„ `width` å’Œ `height` å±æ€§æ¥è®¾ç½®
2. æ˜¾ç¤ºå°ºå¯¸: å±•ç¤ºåœ¨æµè§ˆå™¨ä¸­çš„å°ºå¯¸, é»˜è®¤æƒ…å†µä¸‹, æ˜¯å’Œ `HTMLCanvasElement` ç±»çš„ `width` å’Œ `height` ç›¸åŒ, å¦‚æœéè¦ä¸åŒå°±ä¼šæ‹‰ä¼¸/ç¼©æ”¾

::: code-group

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 200;
    canvasDom.height = 200;
    return canvasDom;
  }

  function drawLine(canvasDom) {
    const ctx = canvasDom.getContext("2d");
    ctx.moveTo(50, 50);
    ctx.lineTo(100, 50);
    ctx.stroke();
  }

  drawLine(initCanvasDom("app"));
  drawLine(initCanvasDom("app2"));
};
```

```html{25,26}
<!doctype html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="no-referrer" />
    <title>Canvas and SVG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        padding: 20px;
      }
      #app {
        background: #f00;
      }
      #app2 {
        background: #f00;
        width: 400px;
        height: 400px;
      }
    </style>
  </head>
  <body>
    <canvas id="app">Your browser does not support the canvas element.</canvas>
    <canvas id="app2">Your browser does not support the canvas element.</canvas>
    <script src="./index.js" type="module"></script>
  </body>
</html>
```

:::

![diff](https://raw.githubusercontent.com/liaohui5/images/main/images/202511181608619.png)

## ç”»çº¿æ¡

### ç»˜åˆ¶çº¿æ¡å¹¶è®¾ç½®æ ·å¼

- [lineWidth](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineWidth)
- [lineCap](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineCap)
- [lineJoin](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineJoin)
- [strokeStyle](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/strokeStyle)

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  // è®¾ç½®çº¿æ¡çš„ç²—ç»†(é«˜åº¦)
  ctx.lineWidth = 10;

  // è®¾ç½®çº¿æ¡çš„æ ·å¼
  ctx.strokeStyle = "#f00";

  // è®¾ç½®çº¿æ¡ä¸¤ç«¯çš„æ ·å¼
  ctx.lineCap = "round"; // butt(é»˜è®¤)/round/square

  // è®¾ç½®çº¿æ¡é“¾æ¥å¤„çš„æ ·å¼(éœ€è¦ä¸¤æ¡çº¿æ‰èƒ½çœ‹å‡ºæ•ˆæœæ¥)
  ctx.lineJoin = "round"; // miter(é»˜è®¤)/round/bevel

  ctx.moveTo(50, 50);
  ctx.lineTo(200, 50);
  ctx.stroke();
};
```

![lin-style](https://raw.githubusercontent.com/liaohui5/images/main/images/202511181634877.png)

### ç»˜åˆ¶å¤šä¸ªçº¿æ¡

- [beginPath](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/beginPath)

```js {20-23}
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  // line1
  ctx.moveTo(50, 50);
  ctx.lineTo(200, 50);
  ctx.lineWidth = 10;
  ctx.strokeStyle = "#f00";
  ctx.stroke();

  // line2
  // å¦‚æœæ²¡æœ‰è°ƒç”¨ beginPath å¼€å¯æ–°çš„ç»˜åˆ¶è·¯å¾„(æ‹¿èµ·å¦å¤–ä¸€æ”¯ç¬”)
  // é‚£ä¹ˆå‰é¢ line1 çš„æ ·å¼ä¼šè¢«åé¢è®¾ç½®çš„æ ·å¼ç»™è¦†ç›–æ‰
  // å› æ­¤ä¸ºäº†é¿å…å½±å“, åº”è¯¥æ¯æ¬¡åˆ’çº¿ä¹‹å‰æ‹¿èµ·æ–°çš„ä¸€æ”¯ç¬”(è°ƒç”¨: beginPath)
  ctx.beginPath();
  ctx.moveTo(50, 100);
  ctx.lineTo(300, 100);
  ctx.lineWidth = 20;
  ctx.strokeStyle = "#0f0";
  ctx.stroke();
};
```

### åˆ©ç”¨çº¿æ¡ç»˜åˆ¶ä¸€äº›ç®€å•å›¾å½¢

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  function drawLines(startPos = { x: 0, y: 0 }, linesPos = [], lineColor = "#f00", lineWidth = 10) {
    ctx.beginPath();
    ctx.moveTo(startPos.x, startPos.y);

    for (let i = 0; i < linesPos.length; i++) {
      const linePos = linesPos[i];
      ctx.lineTo(linePos.x, linePos.y);
    }

    ctx.strokeStyle = lineColor;
    ctx.lineWidth = lineWidth;
    ctx.stroke();
  }

  // ä¸‰è§’å½¢
  drawLines({ x: 100, y: 100 }, [
    { x: 100, y: 200 },
    { x: 200, y: 200 },
    // é»˜è®¤æƒ…å†µä¸‹ä¸ä¼šä»æœ€åä¸€ä¸ªç‚¹é“¾æ¥åˆ°ç¬¬ä¸€ä¸ªç‚¹,
    // æ‰€ä»¥éœ€è¦æœ€åä¸€ä¸ªç‚¹å’Œç¬¬ä¸€ä¸ªç‚¹ä½ç½®ä¸€æ ·,è¿™æ ·æ‰èƒ½é—­åˆ
    { x: 100, y: 100 },
  ]);

  // æ­£æ–¹å½¢
  drawLines({ x: 100, y: 300 }, [
    { x: 200, y: 300 },
    { x: 200, y: 400 },
    { x: 100, y: 400 },
    { x: 100, y: 300 },
  ]);
};
```

![preview](https://raw.githubusercontent.com/liaohui5/images/main/images/202511181707615.png)

ç”±ä¸Šå›¾å¯ä»¥å‘ç°, åˆ©ç”¨æœ€åä¸€ä¸ªç‚¹å’Œç¬¬ä¸€ä¸ªç‚¹é‡åˆçš„æ–¹å¼é—­åˆåˆ’çº¿çš„æ–¹å¼, ä¼šè®©è¿æ¥å¤„å‡ºç° "ç‘•ç–µ"

é‚£æœ‰æ²¡æœ‰åŠæ³•å¯ä»¥é¿å…è¿™ä¸ª "ç‘•ç–µ" å‘¢? è®©æœ€åä¸€ä¸ªç‚¹è‡ªåŠ¨è¿æ¥åˆ°èµ·å§‹ç‚¹

### é—­åˆè·¯å¾„

- [closePath](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/closePath)

```js {21-22,33-35,43}
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  function drawLines(startPos = { x: 0, y: 0 }, linesPos = [], lineColor = "#f00", lineWidth = 10) {
    ctx.beginPath();
    ctx.moveTo(startPos.x, startPos.y);

    for (let i = 0; i < linesPos.length; i++) {
      const linePos = linesPos[i];
      ctx.lineTo(linePos.x, linePos.y);
    }

    // é—­åˆè·¯å¾„:è®©æœ€åä¸€ä¸ªç‚¹è‡ªåŠ¨è¿æ¥åˆ°èµ·å§‹ç‚¹
    ctx.closePath();

    ctx.strokeStyle = lineColor;
    ctx.lineWidth = lineWidth;
    ctx.stroke();
  }

  // ä¸‰è§’å½¢
  drawLines({ x: 100, y: 100 }, [
    { x: 100, y: 200 },
    { x: 200, y: 200 },
    // é»˜è®¤æƒ…å†µä¸‹ä¸ä¼šä»æœ€åä¸€ä¸ªç‚¹é“¾æ¥åˆ°ç¬¬ä¸€ä¸ªç‚¹,
    // æ‰€ä»¥éœ€è¦æœ€åä¸€ä¸ªç‚¹å’Œç¬¬ä¸€ä¸ªç‚¹ä½ç½®ä¸€æ ·,è¿™æ ·æ‰èƒ½é—­åˆ
    // { x: 100, y: 100 },
  ]);

  // æ­£æ–¹å½¢
  drawLines({ x: 100, y: 300 }, [
    { x: 200, y: 300 },
    { x: 200, y: 400 },
    { x: 100, y: 400 },
    // { x: 100, y: 300 },
  ]);
};
```

### ç»˜åˆ¶è™šçº¿

- [setLineDash](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash)
- [getLineDash](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getLineDash)
- [lineDashOffset](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset)

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  function drawLine(startPos = { x: 0, y: 0 }, dashes = [5]) {
    ctx.beginPath();
    ctx.moveTo(startPos.x, startPos.y);
    ctx.lineTo(startPos.x + 300, startPos.y);
    ctx.strokeStyle = "red";
    ctx.lineWidth = 10;
    ctx.setLineDash(dashes);
    ctx.stroke();
  }

  drawLine({ x: 100, y: 150 }, [5]);
  console.log("lineDash-1", ctx.getLineDash());
  // [5, 5]

  drawLine({ x: 100, y: 250 }, [5, 10]);
  console.log("lineDash-2", ctx.getLineDash());
  // [5, 10]

  drawLine({ x: 100, y: 300 }, [5, 10, 15]);
  console.log("lineDash-3", ctx.getLineDash());
  // [5, 10, 15, 5, 10, 15]

  drawLine({ x: 100, y: 350 }, [5, 10, 15, 20]);
  console.log("lineDash-4", ctx.getLineDash());
  // [5, 10, 15, 20]
};
```

![dash](https://raw.githubusercontent.com/liaohui5/images/main/images/202511181905610.png)

## å¡«å……å›¾å½¢

- [fillStyle](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillStyle)
- [fill](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fill)

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  function drawRect(positionArray = [], color = "#f00") {
    if (positionArray.length < 3) {
      return;
    }
    const [startPos, ...linesPos] = positionArray;
    ctx.beginPath();
    ctx.moveTo(startPos.x, startPos.y);
    for (let i = 0; i < linesPos.length; i++) {
      const item = linesPos[i];
      ctx.lineTo(item.x, item.y);
    }
    ctx.closePath();

    ctx.strokeStyle = color;
    ctx.lineWidth = 10;
    ctx.stroke();

    // è®¾ç½®å¡«å……é¢œè‰²å¹¶ä¸”å¡«å……
    ctx.fillStyle = color;
    ctx.fill();
  }

  drawRect([
    { x: 100, y: 100 },
    { x: 300, y: 100 },
    { x: 300, y: 300 },
    { x: 100, y: 300 },
  ]);
};
```

### éé›¶ç¯ç»•åŸåˆ™

::: danger æ³¨æ„
åªæœ‰åœ¨åŒä¸€æ¡è·¯å¾„è·¯å¾„ä¸­æ‰ä¼šéµå®ˆè¿™ä¸ªç»˜åˆ¶åŸåˆ™, å¦‚æœæ˜¯ä¸åŒçš„è·¯å¾„æ²¡æœ‰è¿™ä¸ªè§„åˆ™çš„å½±å“
:::

1. æ¯æ¬¡å¡«å……å‰ä»å›¾å½¢çš„ä¸­å¿ƒæ‹‰å‡ºä¸€æ¡çº¿, çœ‹è·¯å¾„ä¸Šä¸ä¹‹ç›¸äº¤çš„ç‚¹æ˜¯é¡ºæ—¶é’ˆè¿˜æ˜¯é€†æ—¶é’ˆ
2. é»˜è®¤ `x = 0` å¦‚æœæ˜¯é€†æ—¶é’ˆé‚£ä¹ˆ `x + 1`, å¦‚æœæ˜¯é¡ºæ—¶é’ˆé‚£ä¹ˆ `x - 1`
3. æœ€åå¦‚æœ `x = 0`, å°±ä¸ä¼šå¡«å……, å¦‚æœç»“æœéé›¶é‚£ä¹ˆå°±ä¼šå¡«å……

æ³¨: è¿™ä¸ªè§„åˆ™ä¸­çš„ x æ˜¯è¡¨ç¤ºä¸€ä¸ªæœªçŸ¥æ•°, ä¸æ˜¯åæ ‡ä½ç½®çš„æ„æ€

::: code-group

```js {20-24,50-54}
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  // å¤§çš„çŸ©å½¢æ˜¯é¡ºæ—¶é’ˆ, æ‰€ä»¥: x += 1
  ctx.moveTo(100, 100);
  ctx.lineTo(300, 100);
  ctx.lineTo(300, 300);
  ctx.lineTo(100, 300);
  ctx.closePath();

  // å°çš„çŸ©å½¢ä¹Ÿæ˜¯é¡ºæ—¶é’ˆ x += 1
  ctx.moveTo(150, 150);
  ctx.lineTo(250, 150);
  ctx.lineTo(250, 250);
  ctx.lineTo(150, 250);
  ctx.closePath();

  // æ³¨: æˆ‘åª stroke ç»˜åˆ¶äº†ä¸€æ¬¡, ä¸”æ˜¯åŒä¸€ä¸ª path
  const fillColor = "#f00";
  ctx.strokeStyle = fillColor;
  ctx.lineWidth = 10;
  ctx.fillStyle = fillColor;
  ctx.stroke();
  ctx.fill();

  // æœ€å: å¤§çŸ©å½¢çš„ x = 1, å°çŸ©å½¢çš„ x = 2, æ‰€ä»¥éƒ½ä¼šå¡«å……

  ///////////////////////////////////////////////////////
  // è¿™æ˜¯ç¬¬äºŒä¸ª canvas, æ³¨æ„å¯¹æ¯”: å°çŸ©å½¢çš„ç»˜åˆ¶é¡ºåºä¸åŒ //
  ///////////////////////////////////////////////////////
  const canvasDom2 = initCanvasDom("app2");
  const ctx2 = canvasDom2.getContext("2d");

  // å¤§çš„çŸ©å½¢æ˜¯é¡ºæ—¶é’ˆ, æ‰€ä»¥: x += 1
  ctx2.moveTo(100, 100);
  ctx2.lineTo(300, 100);
  ctx2.lineTo(300, 300);
  ctx2.lineTo(100, 300);
  ctx2.closePath();

  // å°çš„çŸ©å½¢ä¹Ÿæ˜¯é¡ºæ—¶é’ˆ, æ‰€ä»¥: x -= 1
  ctx2.moveTo(250, 150);
  ctx2.lineTo(150, 150);
  ctx2.lineTo(150, 250);
  ctx2.lineTo(250, 250);
  ctx2.closePath();

  // æ³¨: æˆ‘åª stroke ç»˜åˆ¶äº†ä¸€æ¬¡, ä¸”æ˜¯åŒä¸€ä¸ª path
  ctx2.strokeStyle = fillColor;
  ctx2.lineWidth = 10;
  ctx2.fillStyle = fillColor;
  ctx2.stroke();
  ctx2.fill();

  // æœ€å: å¤§çŸ©å½¢çš„ x = 1, å°çŸ©å½¢çš„ x = 0, æ‰€ä»¥å°çŸ©å½¢ä¸ä¼šç»˜åˆ¶
};
```

```html
<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="no-referrer" />
    <title>Canvas and SVG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        padding: 20px;
      }
      #app,
      #app2 {
        border: 1px solid #f00;
      }
    </style>
  </head>
  <body>
    <canvas id="app">Your browser does not support the canvas element.</canvas>
    <canvas id="app2">Your browser does not support the canvas element.</canvas>
    <script src="./index.js" type="module"></script>
  </body>
</html>
```

:::

![shun](https://raw.githubusercontent.com/liaohui5/images/main/images/202511181840779.png)
![ni](https://raw.githubusercontent.com/liaohui5/images/main/images/202511181842331.png)

æœ€åçœ‹æ•ˆæœå›¾, è¯´æ˜, ç»“è®ºæ²¡é”™:
![preview](https://raw.githubusercontent.com/liaohui5/images/main/images/202511181844030.png)

## ç»ƒä¹ :ç»˜åˆ¶æŠ˜çº¿å›¾è¡¨æ ¼

::: code-group

```js [å®ç°æ­¥éª¤]
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  const gridSize = 50;
  const { width, height } = ctx.canvas;
  const rows = Math.floor(height / gridSize);
  const cols = Math.floor(width / gridSize);

  // ç»˜åˆ¶ç½‘æ ¼
  for (let i = 0; i < rows; i++) line chart{
    const y = i * gridSize - 0.5;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(width, y);
    ctx.stroke();
  }

  for (let i = 0; i < cols; i++) {
    const x = i * gridSize - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, height);
    ctx.stroke();
  }

  // è®¡ç®—åæ ‡ç³»èµ·ç‚¹ å’Œ ç»ˆç‚¹
  const originPos = {
    x: gridSize,line chart
    y: height - gridSize,
  };
  const targetPos = {
    x: width - gridSize,
    y: gridSize,
  };

  // ç»˜åˆ¶ x è½´
  ctx.beginPath();
  ctx.moveTo(originPos.x, originPos.y);
  ctx.lineTo(targetPos.x, originPos.y);
  ctx.strokeStyle = "#f00";
  ctx.stroke();

  // ç»˜åˆ¶xè½´ç®­å¤´line chart
  ctx.beginPath();
  ctx.lineTo(targetPos.x - 10, originPos.y - 5);
  ctx.lineTo(targetPos.x - 10, originPos.y + 5);
  ctx.lineTo(targetPos.x, originPos.y);
  ctx.closePath();
  ctx.fillStyle = "#f00";
  ctx.fill();
  ctx.stroke();

  // ç»˜åˆ¶ y è½´
  ctx.beginPath();
  ctx.moveTo(originPos.x, originPos.y);
  ctx.lineTo(originPos.x, targetPos.y);
  ctx.strokeStyle = "#f00";
  ctx.stroke();

  // ç»˜åˆ¶yè½´ç®­å¤´
  ctx.beginPath();
  ctx.lineTo(originPos.x - 5, targetPos.y + 10);
  ctx.lineTo(originPos.x + 5, targetPos.y + 10);
  ctx.lineTo(originPos.x, targetPos.y);
  ctx.closePath();
  ctx.fillStyle = "#f00";
  ctx.fill();
  ctx.stroke();

  // æ¨¡æ‹ŸæŠ˜çº¿å›¾ç‚¹çš„åæ ‡æ•°æ®
  const tableData = [
    { x: 100, y: 300 },
    { x: 200, y: 200 },
    { x: 300, y: 250 },
    { x: 400, y: 150 },
    { x: 400, y: 150 },
  ];

  // ç»˜åˆ¶æŠ˜çº¿å›¾æ‰€æœ‰çš„ç‚¹
  const dotSize = 10;
  const halfDotSize = dotSize / 2;
  for (let i = 0; i < tableData.length; i++) {
    const item = tableData[i];
    ctx.beginPath();
    ctx.moveTo(item.x - halfDotSize, item.y - halfDotSize);
    ctx.lineTo(item.x + dotSize - halfDotSize, item.y - halfDotSize);
    ctx.lineTo(item.x + dotSize - halfDotSize, item.y + dotSize - halfDotSize);
    ctx.lineTo(item.x - halfDotSize, item.y + dotSize - halfDotSize);
    ctx.closePath();
    ctx.fillStyle = "#f00";
    ctx.fill();
    ctx.strokeStyle = "#f00";
    ctx.stroke();
  }

  // ç»˜åˆ¶æŠ˜çº¿å›¾æ‰€æœ‰ç‚¹ä¹‹é—´çš„è¿çº¿
  const [start, ...dots] = tableData;
  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  ctx.lineWidth = 2;
  for (let i = 0; i < dots.length; i++) {
    const dot = dots[i];
    ctx.lineTo(dot.x, dot.y);
  }
  ctx.strokeStyle = "#f00";
  ctx.stroke();
};
```

```js [ç®€å•å°è£…]
class LineChart {
  canvasContext = null;
  constructor(width = 300, height = 300) {
    const canvasDom = document.createElement("canvas");
    canvasDom.width = width;
    canvasDom.height = height;
    this.canvasContext = canvasDom.getContext("2d");
    document.body.appendChild(canvasDom);
  }

  drawGrid(gridSize = 50) {
    const ctx = this.canvasContext;
    const { width, height } = ctx.canvas;
    const rows = Math.floor(height / gridSize);
    const cols = Math.floor(width / gridSize);

    // ç»˜åˆ¶è¡Œ
    for (let i = 0; i < rows; i++) {
      const y = i * gridSize - 0.5;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }

    // ç»˜åˆ¶åˆ—
    for (let i = 0; i < cols; i++) {
      const x = i * gridSize - 0.5;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
  }

  // ç»˜åˆ¶åæ ‡ç³»
  drawCoor(gridSize = 50, coorColor = "#f00") {
    const ctx = this.canvasContext;
    const { width, height } = ctx.canvas;

    // è®¡ç®—åæ ‡ç³»èµ·ç‚¹ å’Œ ç»ˆç‚¹
    const originPos = {
      x: gridSize,
      y: height - gridSize,
    };
    const targetPos = {
      x: width - gridSize,
      y: gridSize,
    };
    this.originPos = originPos;
    this.targetPos = targetPos;

    // ç»˜åˆ¶ x è½´
    ctx.beginPath();
    ctx.moveTo(originPos.x, originPos.y);
    ctx.lineTo(targetPos.x, originPos.y);
    ctx.strokeStyle = coorColor;
    ctx.stroke();

    // ç»˜åˆ¶xè½´ç®­å¤´
    ctx.beginPath();
    ctx.lineTo(targetPos.x - 10, originPos.y - 5);
    ctx.lineTo(targetPos.x - 10, originPos.y + 5);
    ctx.lineTo(targetPos.x, originPos.y);
    ctx.closePath();
    ctx.fillStyle = coorColor;
    ctx.fill();
    ctx.stroke();

    // ç»˜åˆ¶ y è½´
    ctx.beginPath();
    ctx.moveTo(originPos.x, originPos.y);
    ctx.lineTo(originPos.x, targetPos.y);
    ctx.strokeStyle = coorColor;
    ctx.stroke();

    // ç»˜åˆ¶yè½´ç®­å¤´
    ctx.beginPath();
    ctx.lineTo(originPos.x - 5, targetPos.y + 10);
    ctx.lineTo(originPos.x + 5, targetPos.y + 10);
    ctx.lineTo(originPos.x, targetPos.y);
    ctx.closePath();
    ctx.fillStyle = coorColor;
    ctx.fill();
    ctx.stroke();
  }

  // ç»˜åˆ¶æŠ˜çº¿å›¾æ‰€æœ‰çš„ç‚¹
  drawDots(tableData = [], dotSize = 10, dotColor = "#f00") {
    const ctx = this.canvasContext;
    const halfDotSize = dotSize / 2;
    for (let i = 0; i < tableData.length; i++) {
      const item = tableData[i];
      ctx.beginPath();
      ctx.moveTo(item.x - halfDotSize, item.y - halfDotSize);
      ctx.lineTo(item.x + dotSize - halfDotSize, item.y - halfDotSize);
      ctx.lineTo(item.x + dotSize - halfDotSize, item.y + dotSize - halfDotSize);
      ctx.lineTo(item.x - halfDotSize, item.y + dotSize - halfDotSize);
      ctx.closePath();
      ctx.fillStyle = dotColor;
      ctx.fill();
      ctx.strokeStyle = dotColor;
      ctx.stroke();
    }
  }

  // ç»˜åˆ¶æŠ˜çº¿å›¾æ‰€æœ‰ç‚¹ä¹‹é—´çš„è¿çº¿
  drawLines(tableData = [], lineWidth = 2, lineColor = "#f00") {
    const ctx = this.canvasContext;
    const [start, ...dots] = tableData;
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineWidth = lineWidth;
    for (let i = 0; i < dots.length; i++) {
      const dot = dots[i];
      ctx.lineTo(dot.x, dot.y);
    }
    ctx.strokeStyle = lineColor;
    ctx.stroke();
  }

  // ç»˜åˆ¶æŸ±çŠ¶å›¾çŸ©å½¢(åç»­ä¼šå­¦åˆ°)
  drawBars(tableData = [], gridSize = 50, barColor = "#f00") {
    const ctx = this.canvasContext;
    for (const item of tableData) {
      ctx.fillRect(item.x, item.y, gridSize, this.originPos.y - item.y);
    }
  }
}

window.onload = function () {
  const lineChart = new LineChart(500, 500);
  lineChart.drawGrid();
  lineChart.drawCoor();

  const tableData = [
    { x: 100, y: 300 },
    { x: 200, y: 200 },
    { x: 300, y: 250 },
    { x: 400, y: 150 },
    { x: 400, y: 150 },
  ];
  lineChart.drawDots(tableData);
  lineChart.drawLines(tableData);
};
```

:::

![line-chart](https://raw.githubusercontent.com/liaohui5/images/main/images/202511182011428.png)

## ç»˜åˆ¶/æ¸…é™¤çŸ©å½¢

- [rect](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/rect)
  ç»˜åˆ¶çŸ©å½¢ä½†å¹¶ä¸ä¼šç«‹å³ stroke æˆ– fill,éœ€è¦æ‰‹åŠ¨ stroke/fill æ‰èƒ½ç»˜åˆ¶, å¹¶ä¸”è°ƒç”¨å¤šæ¬¡ä¹Ÿæ˜¯ä¸€ä¸ª Path, éœ€è¦æ‰‹åŠ¨ beginPath
- [strokeRect](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/strokeRect) ç»˜åˆ¶çŸ©å½¢å¹¶ä¸”ç«‹å³ stroke
- [fillRect](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillRect) ç»˜åˆ¶çŸ©å½¢å¹¶ä¸”ç«‹å³ fill
- [clearRect](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clearRect) æ¸…é™¤çŸ©å½¢, æ¸…é™¤çŸ©å½¢å†…çš„å¡«å……é¢œè‰²å’Œçº¿æ¡ç­‰

è€… 3 ä¸ªå‡½æ•°çš„å‚æ•°éƒ½æ˜¯ä¸€æ ·çš„: `rect(x, y, width, height)`

- x: èµ·å§‹ç‚¹çš„ x åæ ‡
- y: èµ·å§‹ç‚¹çš„ y åæ ‡
- width: çŸ©å½¢çš„å®½åº¦
- height: çŸ©å½¢çš„é«˜åº¦

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  ctx.strokeStyle = "#f00";
  ctx.rect(10, 10, 100, 100); // è¿™ä¸ªå°±ç­‰åŒäºä¸‹é¢è¿™ 5 è¡Œä»£ç 
  // ctx.moveTo(10, 10);
  // ctx.lineTo(100, 10);
  // ctx.lineTo(100, 100);
  // ctx.lineTo(10, 100);
  // ctx.closePath();
  ctx.stroke(); // éœ€è¦æ‰‹åŠ¨ stroke/fill æ‰ä¼šç»˜åˆ¶å‡ºæ¥

  ctx.strokeStyle = "#0f0";
  ctx.strokeRect(120, 120, 100, 100); // è¿™ä¸ªä»£ç å°±ç­‰åŒäºä¸‹é¢è¿™ 7 è¡Œä»£ç 
  // ctx.beginPath();
  // ctx.moveTo(120, 120);
  // ctx.lineTo(120 + 100, 120);
  // ctx.lineTo(120 + 100, 120 + 100);
  // ctx.lineTo(120, 120 + 100);
  // ctx.closePath();
  // ctx.stroke();

  ctx.fillStyle = "#00f";
  ctx.fillRect(230, 230, 100, 100); // è¿™ä¸ªä»£ç å°±ç­‰åŒäºä¸‹é¢è¿™ 7 è¡Œä»£ç 
  // ctx.beginPath();
  // ctx.moveTo(230, 230);
  // ctx.lineTo(230 + 100, 230);
  // ctx.lineTo(230 + 100, 230 + 100);
  // ctx.lineTo(230, 230 + 100);
  // ctx.closePath();
  // ctx.fill();

  // æ¸…ç©ºæ‰€æœ‰å†…å®¹: è°ƒç”¨åä¸Šé¢ç»˜åˆ¶çš„å†…å®¹å…¨éƒ¨è¢«æ¸…é™¤
  const { width, height } = ctx.canvas;
  ctx.clearRect(0, 0, width, height);
};
```

## æ¸å˜è‰²

- [createLinearGradient](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createLinearGradient) åˆ›å»ºçº¿æ€§æ¸å˜æ–¹æ¡ˆ(å¸¸ç”¨)
- [createRadialGradient](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createRadialGradient) åˆ›å»ºå¾„å‘æ¸å˜æ–¹æ¡ˆ
- [createConicGradient](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createConicGradient) åˆ›å»ºæ‰‡å½¢æ¸å˜æ–¹æ¡ˆ
- [CanvasGradient](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasGradient) æ¸å˜æ–¹æ¡ˆ

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  // åˆ›å»ºä¸€ä¸ªçº¿æ€§æ¸å˜ createLinearGradient(x1, y1, x2, y2)
  // x1, y1 å’Œ x2, y2 çš„åæ ‡å¯ä»¥æ„æˆä¸€æ¡çº¿, è¿™çº¿å°±æ˜¯æ¸å˜çš„æ–¹å‘
  // æ¸å˜èµ·ç‚¹: x1=10  y1=10
  // æ¸å˜ç»ˆç‚¹: x2=110 y2=10
  // ä¸ºä»€ä¹ˆæ˜¯ 10, 20, 110, 20 å› ä¸ºæ¸å˜æ–¹æ¡ˆä» 0 å¼€å§‹è®¡ç®—
  // å› ä¸ºçŸ©å½¢èµ·å§‹ç‚¹ç¦»å·¦è¾¹æœ‰ 10 åƒç´ æ‰€ä»¥éœ€è¦ çŸ©å½¢å®½åº¦ + 10
  // const gradient = ctx.createLinearGradient(10, 20, 110, 20); // ä»å·¦åˆ°å³æ¸å˜
  const gradient = ctx.createLinearGradient(10, 20, 110, 120); // ä»å·¦ä¸Šåˆ°å³ä¸‹æ¸å˜

  // æ·»åŠ è‰²æ ‡: addColorStop(progress, color)
  // progress æ˜¯ä¸€ä¸ªå€¼åœ¨ 0-1 è¡¨ç¤ºæ¸å˜è¿›åº¦
  // color    é¢œè‰²
  gradient.addColorStop(0, "#f00");
  gradient.addColorStop(0.5, "#0f0");
  gradient.addColorStop(1, "#00f");

  // å¡«å……çŸ©å½¢
  ctx.fillStyle = gradient;
  ctx.fillRect(10, 20, 100, 100);
};
```

## ç»˜åˆ¶åœ†å¼§

### åŸºç¡€çŸ¥è¯†äº†è§£

- è§’åº¦: ä¸€ä¸ªåœ† 360 åº¦(è§’åº¦), ä¸€ä¸ªåŠåœ†æ˜¯ 180 åº¦
- å¼§åº¦: ä¸€ä¸ªåœ† Ï€, ä¸€ä¸ªåŠåœ†æ˜¯ Ï€/2

```
è§’åº¦è½¬å¼§åº¦å…¬å¼:
  å› ä¸º: 180è§’åº¦ = Ï€ å¼§åº¦
  æ‰€ä»¥: 1è§’åº¦ = Ï€/180
  æ‰€ä»¥: å¼§åº¦ = è§’åº¦ * Ï€/180
        90è§’åº¦ * Ï€/180 = Ï€/2

å¼§åº¦è½¬è§’åº¦
  å› ä¸º: Ï€ å¼§åº¦ = 180è§’åº¦
  æ‰€ä»¥: 1 å¼§åº¦ = 180/Ï€
  æ‰€ä»¥: è§’åº¦ = å¼§åº¦ * 180/Ï€
       Ï€/2 * 180/Ï€ = 90 è§’åº¦
```

### ç»˜åˆ¶åœ†å½¢

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  // ctx.arc(x, y, round, startAngle, endAngle, isCounterclockwise);
  // x,y:        åœ†å¿ƒåæ ‡
  // round:      åŠå¾„
  // startAngle: èµ·å§‹è§’åº¦
  // endAngle:   ç»“æŸè§’åº¦
  // isCounterclockwise: æ˜¯å¦æ˜¯é€†æ—¶é’ˆæ–¹å‘ç»˜åˆ¶, é»˜è®¤false(é¡ºæ—¶é’ˆæ–¹å‘)

  ctx.arc(100, 100, 50, 0, Math.PI, false);
  ctx.strokeStyle = "#f00";
  ctx.stroke();

  // ä¸¤ä¸ªåŠåœ†, ä¸€ä¸ªé€†æ—¶é’ˆ, ä¸€ä¸ªé¡ºæ—¶é’ˆ, ç»„åˆæˆä¸€ä¸ªåœ†
  ctx.beginPath();
  ctx.arc(100, 100, 50, 0, Math.PI, true);
  ctx.strokeStyle = "#0f0";
  ctx.stroke();

  // ç›´æ¥ç»˜åˆ¶ä¸€ä¸ªåœ†å½¢
  ctx.beginPath();
  ctx.arc(200, 200, 50, 0, Math.PI * 2);
  ctx.strokeStyle = "#00f";
  ctx.stroke();
};
```

### ç»˜åˆ¶æ‰‡å½¢

æ‰€è°“æ‰‡å½¢, èµ·å§‹å°±æ˜¯å››åˆ†ä¹‹ä¸€çš„åœ†å½¢

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  ctx.moveTo(200, 200); // è®¾ç½®èµ·ç‚¹ä¸ºåœ†å¿ƒçš„åæ ‡ç‚¹
  ctx.arc(200, 200, 50, 0, Math.PI / 2);
  ctx.strokeStyle = "#00f";
  ctx.closePath(); // ç›´æ¥é—­åˆè·¯å¾„
  ctx.stroke();

  // ç¬¬äºŒä¸ªé€†æ—¶é’ˆæ‰‡å½¢:ä»360Â°(2Ï€)åˆ°270Â°(3Ï€/2), é€†æ—¶é’ˆç»˜åˆ¶90Â°æ‰‡å½¢
  ctx.beginPath();
  ctx.moveTo(200, 200);
  ctx.arc(200, 200, 50, Math.PI * 2, (Math.PI * 3) / 2, true);
  ctx.closePath(); // å›åˆ°åœ†å¿ƒï¼Œå½¢æˆæ‰‡å½¢åŒºåŸŸ
  ctx.strokeStyle = "#0f0";
  ctx.stroke();
};
```

### ç»˜åˆ¶é¥¼çŠ¶å›¾

æ‰€è°“çš„é¥¼çŠ¶å›¾èµ·å§‹å°±æ˜¯å¤šä¸ªæ‰‡å½¢ç»„åˆè€Œæˆ, ä»…æ­¤è€Œå·²

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");
  const ctx = canvasDom.getContext("2d");

  // è®¾å®šåœ†å¿ƒçš„ä½ç½®ä¸ºç”»å¸ƒçš„æ­£ä¸­é—´
  const rx = Math.floor(ctx.canvas.width / 2);
  const ry = Math.floor(ctx.canvas.height / 2);

  /*
  // 4 ç­‰åˆ†åœ†å½¢
  // 0-90
  ctx.moveTo(rx, ry);
  ctx.arc(rx, ry, 100, 0, Math.PI / 2);
  ctx.fillStyle = "#f00";
  ctx.fill();

  // 90-180
  ctx.beginPath()
  ctx.moveTo(rx, ry);
  ctx.arc(rx, ry, 100, Math.PI / 2, Math.PI);
  ctx.fillStyle = "#0f0";
  ctx.fill();

  // 180-270
  ctx.beginPath()
  ctx.moveTo(rx, ry);
  ctx.arc(rx, ry, 100, Math.PI, Math.PI + Math.PI / 2);
  ctx.fillStyle = "#00f";
  ctx.fill();

  // 270-360
  ctx.beginPath()
  ctx.moveTo(rx, ry);
  ctx.arc(rx, ry, 100, Math.PI + Math.PI / 2, Math.PI * 2);
  ctx.fillStyle = "#ff0";
  ctx.fill();
  */

  function randomColor() {
    return `#${Math.floor(Math.random() * 0xffffff).toString(16)}`;
  }

  let startAngle = 0;
  for (let i = 1; i <= 4; i++) {
    const endAngle = (i * Math.PI) / 2;
    ctx.beginPath();
    ctx.moveTo(rx, ry);
    ctx.arc(rx, ry, 100, startAngle, endAngle);
    ctx.fillStyle = randomColor();
    ctx.fill();
    ctx.closePath();
    startAngle = endAngle;
  }
};
```

![cookie](https://raw.githubusercontent.com/liaohui5/images/main/images/202511182337141.png)

## ç»˜åˆ¶æ–‡å­—

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 500;
    canvasDom.height = 500;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");

  /** @type {CanvasRenderingContext2D} */
  const ctx = canvasDom.getContext("2d");

  const { width, height } = ctx.canvas;
  const halfWidth = Math.floor(width / 2);
  const halfHeight = Math.floor(height / 2);

  // å‚è€ƒåæ ‡çº¿
  ctx.moveTo(halfWidth, halfHeight);
  ctx.lineTo(0, halfHeight);
  ctx.lineTo(width, halfHeight);
  ctx.moveTo(halfWidth, halfHeight);
  ctx.lineTo(halfWidth, 0);
  ctx.lineTo(halfWidth, height);
  ctx.stroke();

  // ç»˜åˆ¶çŸ©å½¢: ä»¥çŸ©å½¢çš„å·¦ä¸Šè§’ä½œä¸ºå‚è€ƒåæ ‡
  // ç»˜åˆ¶æ–‡å­—: ä»¥æ–‡å­—çš„å·¦ä¸‹è§’ä½œä¸ºå‚è€ƒåæ ‡
  ctx.fillStyle = "#f00";
  ctx.fillRect(halfWidth, halfHeight, 100, 100);

  // è®¾ç½®æ–‡å­—çš„å¤§å°å’Œæ ·å¼
  ctx.font = "30px å¾®è½¯é›…é»‘";

  // è®¾ç½®æ–‡å­—å‚ç›´æ–¹å‘çš„å¯¹é½æ–¹å¼, ä»¥ç»˜åˆ¶æ–‡å­—çš„ Y åæ ‡ä½œä¸ºå‚è€ƒç‚¹
  ctx.textBaseline = "bottom"; // top/bottom/middle/alphabetic/ideographic

  // è®¾ç½®æ–‡å­—æ°´å¹³æ–¹å‘çš„å¯¹é½æ–¹å¼, ä»¥ç»˜åˆ¶æ–‡å­—çš„ X åæ ‡ä½œä¸ºå‚è€ƒç‚¹
  ctx.textAlign = "left"; // start/centerã€€/end/left/right

  // æ–‡å­—æè¾¹
  // ctx.strokeText("hello world", halfWidth, halfHeight);

  // å¡«å……æ–‡å­—(å®å¿ƒçš„)
  ctx.fillText("hello world", halfWidth, halfHeight);
};
```

![text](https://raw.githubusercontent.com/liaohui5/images/main/images/202511190019559.png)

## ç»˜åˆ¶å›¾ç‰‡

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 600;
    canvasDom.height = 600;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");

  /** @type {CanvasRenderingContext2D} */
  const ctx = canvasDom.getContext("2d");

  const img = new Image();
  img.onload = function () {
    // å¦‚æœåªæœ‰ 3 ä¸ªå‚æ•°: drawImage(img, x, y)
    // img: æ˜¯éœ€è¦ç»˜åˆ¶çš„ å›¾ç‰‡
    // x,y: åé¢ä¸¤ä¸ªå‚æ•°å°±æ˜¯è®¾ç½®å›¾ç‰‡å¼€å§‹ç»˜åˆ¶çš„ä½ç½®(å›¾ç‰‡å·¦ä¸Šè§’)
    // ctx.drawImage(img, 10, 10);

    // å¦‚æœåªæœ‰ 5 ä¸ªå‚æ•°: drawImage(img, x, y, w, h)
    // img: æ˜¯éœ€è¦ç»˜åˆ¶çš„ å›¾ç‰‡
    // x,y: è®¾ç½®å›¾ç‰‡å¼€å§‹ç»˜åˆ¶çš„ä½ç½®(å›¾ç‰‡å·¦ä¸Šè§’)
    // w,h: è®¾ç½®ç»˜åˆ¶çš„å›¾ç‰‡çš„å®½åº¦/é«˜åº¦(ä¼šæ‹‰ä¼¸)
    // ctx.drawImage(img, 10, 10, 300, 100);

    // å¦‚æœæœ‰ 9 ä¸ªå‚æ•°: drawImage(img, imgX1, imgY1, imgX2, imgY2, x, y, w, h)
    // img: æ˜¯éœ€è¦ç»˜åˆ¶çš„å›¾ç‰‡(è¢«æˆªå–åçš„å›¾ç‰‡)
    // imgX1,imgY1: ä»¥åŸå›¾ç‰‡çš„å·¦ä¸Šè§’ä½œä¸ºå‚è€ƒ, è®¾ç½®æˆªå–çš„å¼€å§‹ä½ç½®
    // imgX2,imgY2: ä»¥åŸå›¾ç‰‡çš„å·¦ä¸Šè§’ä½œä¸ºå‚è€ƒ, è®¾ç½®æˆªå–çš„ç»“æŸä½ç½®
    // x,y: è®¾ç½®å›¾ç‰‡å¼€å§‹ç»˜åˆ¶çš„ä½ç½®(å›¾ç‰‡å·¦ä¸Šè§’)
    // w,h: è®¾ç½®ç»˜åˆ¶çš„å›¾ç‰‡çš„å®½åº¦/é«˜åº¦(ä¼šæ‹‰ä¼¸)
    ctx.drawImage(img, 10, 10, 150, 150, 100, 100, 120, 120);
  };
  img.src = "https://raw.githubusercontent.com/liaohui5/images/refs/heads/main/images/20220420132604.png";
};
```

![draw-image](https://raw.githubusercontent.com/liaohui5/images/main/images/202511190043582.png)

## å½¢å˜

- [translate](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/translate)
- [rotate](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/rotate)
- [scale](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/scale)

canvas ä¸­ä¸ css çš„å½¢å˜ä¸åŒ, canvas ä¸­æ‰€æœ‰çš„å½¢å˜æ“ä½œ, éƒ½æ˜¯é’ˆå¯¹åæ ‡ç³», è€Œä¸æ˜¯ç»˜åˆ¶çš„å›¾å½¢

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 600;
    canvasDom.height = 600;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");

  /** @type {CanvasRenderingContext2D} */
  const ctx = canvasDom.getContext("2d");

  // æ•´ä¸ªåæ ‡ç³»å‘ x,y ç§»åŠ¨ 100, è€Œä¸æ˜¯ç»˜åˆ¶çš„çŸ©å½¢ç§»åŠ¨
  ctx.translate(100, 100);

  ctx.fillStyle = "#f00";
  ctx.fillRect(50, 50, 100, 100);
  ctx.fillRect(0, 0, 10, 10);

  // å¦‚æœæ³¨é‡Šä¸Šé¢çš„ ctx.translate, æŠŠå½¢å˜çš„æ“ä½œæ”¾åˆ°
  // ç»˜åˆ¶å›¾å½¢çš„åé¢, å°±ä¼šå‘ç°çŸ©å½¢å¹¶ä¸ä¼šç§»åŠ¨
  // ctx.translate(100, 100);
};
```

![translate](https://raw.githubusercontent.com/liaohui5/images/main/images/202511190122120.png)

## åˆæˆæ¨¡å¼

- [globalCompositeOperation](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation)

åœ¨ canvas ä¸­, ä¸åƒ DOM é‚£æ ·æœ‰ `z-index` å±‚çš„æ¦‚å¿µ,
å½“åœ¨ canvas ä¸Šç»˜åˆ¶å›¾å½¢ã€å›¾åƒæˆ–æ–‡æœ¬æ—¶ï¼Œè¿™äº›æ–°å†…å®¹ä¸ä¼šæ€»æ˜¯ç®€å•åœ° `è¦†ç›–` å·²æœ‰å†…å®¹

globalCompositeOperation å†³å®šäº†æ–°ç»˜åˆ¶çš„åƒç´ (ç§°ä¸ºæº source)
å’Œ canvas ä¸Šå·²ç»å­˜åœ¨çš„åƒç´ (ç§°ä¸º ç›®æ ‡ destination) ä¹‹é—´å¦‚ä½•ç»„åˆ
æœ€ç»ˆå†³å®šæ˜¾ç¤ºä»€ä¹ˆé¢œè‰²

```js
window.onload = function () {
  function initCanvasDom() {
    const canvasDom = document.getElementById("canvas");
    canvasDom.width = window.innerWidth;
    canvasDom.height = window.innerHeight;
    return canvasDom;
  }

  const canvasDom = initCanvasDom();

  /** @type {CanvasRenderingContext2D} */
  const ctx = canvasDom.getContext("2d");
  // æ³¨: æ‰€è°“éšè—å…¶å®å°±æ˜¯åƒç´ æ˜¯é€æ˜çš„
  // è¿™ä¸ªå±æ€§å–å€¼éå¸¸å¤š, ä½†æ˜¯æ—¥å¸¸å¼€å‘ä¸­, æœ‰è¿™10ä¸ªåŸºæœ¬å¯ä»¥æå®šäº†
  // å¦‚æœæä¸å®š, å…·ä½“å¯ä»¥æŸ¥çœ‹ mdn æ–‡æ¡£, æœ‰æ›´è¯¦ç»†çš„è§£è¯»ä¾‹å­

  // ä¸¤ä¸ªçŸ©å½¢é‡å çš„åŒºåŸŸæ˜¾ç¤ºç»¿è‰²(è¯´æ˜é‡å åŒºæ˜¾ç¤ºåç»˜åˆ¶çš„é¢œè‰²)
  // ctx.globalCompositeOperation = "source-over"; // é»˜è®¤å€¼

  // ä¸¤ä¸ªçŸ©å½¢é‡å çš„åŒºåŸŸæ˜¾ç¤ºçº¢è‰²çŸ©å½¢(è¯´æ˜é‡å åŒºåŸŸæ˜¾ç¤ºå…ˆç»˜åˆ¶çš„é¢œè‰²)
  // ctx.globalCompositeOperation = "destination-over";

  // çº¢è‰²çŸ©å½¢:å…¨éƒ¨éšè— ç»¿è‰²çŸ©å½¢:ä¸¤ä¸ªçŸ©å½¢é‡å çš„åŒºåŸŸéšè—,ä¸é‡å çš„åŒºåŸŸæ˜¾ç¤º
  // ctx.globalCompositeOperation = "source-out";

  // å°†ä¸¤ä¸ªçŸ©å½¢é‡å åŒºåŸŸçš„é¢œè‰²è¿›è¡Œæ··åˆ(çº¢+ç»¿=é»„)
  // ctx.globalCompositeOperation = "lighter";

  // çº¢è‰²çŸ©å½¢:å…¨éƒ¨éšè— ç»¿è‰²çŸ©å½¢:å…¨éƒ¨æ˜¾ç¤º(ä¹Ÿå°±æ˜¯è¯´ä»…æ˜¾ç¤ºåç»˜åˆ¶çš„çŸ©å½¢)
  // ctx.globalCompositeOperation = "copy";

  // å°†ä¸¤ä¸ªçŸ©å½¢é‡å çš„åŒºåŸŸéšè—
  // ctx.globalCompositeOperation = "xor";

  // å°†ä¸¤ä¸ªçŸ©å½¢é‡å çš„åŒºåŸŸé¢œè‰²å˜é»‘
  // ctx.globalCompositeOperation = "multiply";

  // å°†ä¸¤ä¸ªçŸ©å½¢é‡å çš„åŒºåŸŸé¢œè‰²å˜äº®(æ•ˆæœç±»ä¼¼ lighter)
  // ctx.globalCompositeOperation = "screen";

  // ä¿ç•™äº†åº•å±‚çš„äº®åº¦, åŒæ—¶é‡‡ç”¨äº†é¡¶å±‚çš„è‰²è°ƒå’Œè‰²åº¦: æ··åˆä¸¤ä¸ªçŸ©å½¢é‡å åŒºåŸŸçš„é¢œè‰²
  // ctx.globalCompositeOperation = "color";

  // ä¿æŒåº•å±‚çš„è‰²è°ƒå’Œè‰²åº¦, åŒæ—¶é‡‡ç”¨é¡¶å±‚çš„äº®åº¦
  // ctx.globalCompositeOperation = "luminosity";

  // çº¢è‰²çŸ©å½¢ destination
  ctx.fillStyle = "#f00";
  ctx.fillRect(100, 100, 100, 100);

  // ç»¿è‰²çŸ©å½¢ source
  ctx.fillStyle = "#0f0";
  ctx.fillRect(150, 150, 100, 100);

  // destination
  ctx.fillStyle = "#383838";
  ctx.fillRect(400, 100, 100, 100);

  // source
  ctx.fillStyle = "#ff0000";
  ctx.fillRect(450, 150, 100, 100);
};
```

## å›¾å½¢äº¤äº’

é»˜è®¤æƒ…å†µä¸‹, JS æ— æ³•å’Œ canvas å†…ç»˜åˆ¶çš„å›¾å½¢è¿›è¡Œäº¤äº’,
ä½†æ˜¯å¯ä»¥ç”¨äº‹ä»¶è§¦å‘çš„ä½ç½®å’Œ canvas ç»˜åˆ¶çš„å›¾å½¢çš„ä½ç½®å»åˆ¤æ–­,
æ˜¯å¦ç‚¹å‡»äº†ç»˜åˆ¶çš„å›¾å½¢

```js
window.onload = function () {
  function initCanvasDom(id) {
    const canvasDom = document.getElementById(id);
    canvasDom.width = 600;
    canvasDom.height = 600;
    return canvasDom;
  }

  const canvasDom = initCanvasDom("app");

  /** @type {CanvasRenderingContext2D} */
  const ctx = canvasDom.getContext("2d");

  // rect1
  const rect = {
    x: 50,
    y: 50,
    width: 100,
    height: 100,
  };
  ctx.fillStyle = "#f00";
  ctx.rect(rect.x, rect.y, rect.width, rect.height);
  ctx.fill();

  // rect2
  // ctx.beginPath();
  ctx.rect(200, 200, 100, 100);
  ctx.fill();

  ctx.canvas.addEventListener("click", (e) => {
    // æ‰‹åŠ¨åˆ¤æ–­ä½ç½®
    const { offsetX, offsetY } = e;
    // const maxRectX = rect.x + rect.width;
    // const maxRectY = rect.y + rect.height;
    // if (offsetX >= rect.x && offsetX <= maxRectX && offsetY >= rect.y && offsetY <= maxRectY) {
    //   console.log("inside the rect");
    // } else {
    //   console.log("outside");
    // }

    // ä½¿ç”¨ isPointInPath æ–¹æ³•åˆ¤æ–­:
    // æ³¨æ„: é»˜è®¤æƒ…å†µä¸‹, rect1 rect2 éƒ½ä¼šè¿”å› true
    // ä½†æ˜¯å¦‚æœç»˜åˆ¶ rect2 æ—¶, å¼€å¯äº†æ–°è·¯å¾„ ctx.beginPath()
    // é‚£ä¹ˆå°±åªæœ‰ç‚¹å‡» rect2 ä¼šè¿”å› true, rect1 ä¼šè¿”å› false
    if (ctx.isPointInPath(offsetX, offsetY)) {
      console.log("inside the rect");
    } else {
      console.log("outside");
    }
  });
};
```

## ä½¿ç”¨ HTMLCanvasElement å®ä¾‹æ–¹æ³•å‹ç¼©å›¾ç‰‡ä½“ç§¯

è¿™ä¸ªç±»é™¤äº† `getContext` æ–¹æ³•å¤–, è¿˜æœ‰ä¸€ä¸ª `toBlob` æ–¹æ³•æ¯”è¾ƒå¸¸ç”¨:

- [toBlob](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toBlob) å°† HTMLCanvasElement
  å¯¹è±¡è½¬ä¸ºä¸€ä¸ª [Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) å¯¹è±¡

::: code-group

```js
window.onload = function () {
  const inputDom = document.getElementById("fileInput");
  inputDom.addEventListener("change", async (e) => {
    const [file] = e.target.files;
    const blob = await compressImageAsync(file);

    // upload blob ...
    console.log("blob", blob);
  });

  // å‹ç¼©å›¾ç‰‡
  function compressImageAsync(file, quality = 0.5, imageType = "image/png") {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const image = new Image();
      image.src = url;
      image.onerror = () => reject("compressImageAsync: failed to load image");
      image.onload = function () {
        const canvasDom = document.createElement("canvas");

        // è¿™é‡Œåªæ˜¯å‹ç¼©ä½†æ˜¯å¹¶ä¸ç¼©æ”¾, å¦‚æœéœ€è¦ä¹Ÿå¯ä»¥ç­‰æ¯”ä¾‹ç¼©æ”¾ canvas å®½é«˜
        canvasDom.width = image.width;
        canvasDom.height = image.height;

        /** @type {CanvasRenderingContext2D} */
        const ctx = canvasDom.getContext("2d");
        ctx.drawImage(image, 0, 0); // å°†å›¾ç‰‡ç”»åˆ° canvas ä¸Š

        // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å‹ç¼©å®Œåçš„å›è°ƒå‡½æ•°, å‹ç¼©åçš„ blob æ˜¯å‚æ•°
        // ç¬¬äºŒä¸ªå‚æ•°æ˜¯å‹ç¼©åå›¾ç‰‡çš„æ–‡ä»¶ç±»å‹ jpg/png
        // ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯å‹ç¼©çš„è´¨é‡å–å€¼æ˜¯ 0~1 æ•°å€¼è¶Šä½, å›¾ç‰‡è¶Šæ¨¡ç³Š
        canvasDom.toBlob(resolve, imageType, quality);
      };
    });
  }
};
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <input type="file" id="fileInput" />
    <script type="module" src="./index.js"></script>
  </body>
</html>
```

:::

## Canvas ç»ƒä¹ 

- [x] ç”»æ¿å·¥å…·
- [x] å®ç°æˆªå›¾
- [x] åˆ®åˆ®ä¹æ•ˆæœ
- [x] å¼¹å¹•æ•ˆæœ
- [ ] äº”å­æ£‹
- [ ] è´ªé£Ÿè›‡

### ç”»æ¿å·¥å…·

![preview](https://raw.githubusercontent.com/liaohui5/images/main/images/202511210347397.png)

::: code-group

```html [index.html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas draw board</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
      .tool-bar {
        width: 100%;
        padding: 10px 20px;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 10;
        background: #f8f8f8;
        border-bottom: 1px solid #eee;
        display: flex;
      }
      .tool-bar .item {
        display: inline-flex;
        align-items: center;
        margin-right: 20px;
      }
      .tool-bar .item .label {
        margin-right: 10px;
      }
      .tool-bar .item .status {
        justify-self: flex-end;
      }
    </style>
  </head>
  <body>
    <div class="tool-bar">
      <div class="item">
        <span class="label">é€‰æ‹©é¢œè‰²</span>
        <input type="color" id="colorPicker" />
      </div>
      <div class="item">
        <span class="label">ç¬”ç”»ç²—ç»†</span>
        <input type="range" id="lineWidthPicker" min="1" max="20" />
      </div>
      <div class="item">
        <button id="clearButton" class="label">æ¸…é™¤ç”»å¸ƒ</button>
      </div>
      <div class="item">
        <button id="eraserButton" class="label">æ©¡çš®æ“¦</button>
      </div>
      <div class="item">
        <button id="penButton" class="label">ç”»ç¬”</button>
      </div>
      <div class="item">
        <button id="undoButton" class="label">æ’¤é”€</button>
      </div>
      <div class="item">
        <button id="redoButton" class="label">æ¢å¤</button>
      </div>
      <div class="item status">
        <span class="label" id="statusBar"></span>
      </div>
    </div>
    <script type="module" src="./index.js"></script>
  </body>
</html>
```

```js [index.js]
import Stack from "./stack.js";

/** @type {CanvasRenderingContext2D} */
let canvas2dContext = null;

const PEN_TYPES = {
  PEN: {
    id: "PEN",
    label: "ç”»ç¬”",
  },
  ERASER: {
    id: "ERASER",
    label: "æ©¡çš®æ“¦",
  },
};

const state = {
  // é¼ æ ‡æŒ‰ä¸‹æ—¶çš„ä½ç½®
  mouseDownPos: {
    x: 0,
    y: 0,
  },
  lineCap: "round", // ç”»ç¬”çº¿æ¡ç«¯ç‚¹æ ·å¼
  lineWidth: 10, // å½“å‰ç”»ç¬”å®½åº¦
  pen: PEN_TYPES.PEN, // "ç”»ç¬”" or "æ©¡çš®æ“¦"
  penColor: "#000000", // å½“å‰ç”»ç¬”é¢œè‰²
  cachePenColor: null, // ç¼“å­˜çš„ç”»ç¬”é¢œè‰²(åˆ‡æ¢åˆ°æ©¡çš®æ“¦æ—¶ä½¿ç”¨)
  backgroundColor: "#FFFFFF", // ç”»å¸ƒèƒŒæ™¯è‰²(æ©¡çš®æ“¦é¢œè‰²)
  drawStack: new Stack(), // ç»˜åˆ¶æ“ä½œæ ˆ
  undoStack: new Stack(), // æ’¤é”€æ“ä½œæ ˆ
  getOptions() {
    // è·å–å½“å‰ç”»ç¬”é…ç½®
    return {
      penColor: this.penColor,
      lineCap: this.lineCap,
      lineWidth: this.lineWidth,
    };
  },
  setPenColor(color) {
    this.penColor = color;
    syncCanvasOptions(canvas2dContext, this.getOptions());
  },
  clearCachePenColor() {
    this.cachePenColor = null;
  },
  setCachePenColor(color) {
    this.cachePenColor = color;
  },
  setLineWidth(width) {
    this.lineWidth = width;
    syncCanvasOptions(canvas2dContext, this.getOptions());
  },
  setMouseDownPos(pos) {
    this.mouseDownPos = pos;
  },
  getPenLabel() {
    return `å½“å‰å·¥å…·:${this.pen.label}`;
  },
  setPen() {
    this.pen = PEN_TYPES.PEN;
    this.setPenColor(this.cachePenColor); // restore pen color
    this.clearCachePenColor(); // clear cache
    initStatusBar();
  },
  setEraser() {
    this.pen = PEN_TYPES.ERASER;
    this.setCachePenColor(this.penColor); // cache current pen color
    this.setPenColor(this.backgroundColor); // set pen color to background color
    initStatusBar();
  },
  clearStacks() {
    this.drawStack.clear();
    this.undoStack.clear();
  },
  createDrawRecord() {
    this.drawStack.push({
      id: Math.random().toString(36).substring(2, 10),
      moveTo: [],
      lineTo: [],
      options: this.getOptions(),
    });
  },
  setLastRecordMoveTo(pos) {
    const lastRecord = this.drawStack.peek();
    lastRecord.moveTo = pos;
  },
  setLastRecordLineTo(pos) {
    const lastRecord = this.drawStack.peek();
    lastRecord.lineTo.push(pos);
  },
};

window.onload = init;

function init() {
  initCanvas();
  syncCanvasOptions(canvas2dContext, state.getOptions()); // initial sync
  initColorPicker();
  initLineWidthPicker();
  initClearButton();
  initEraserButton();
  initPenButton();
  initUndoButton();
  initRedoButton();
  initStatusBar();
}

function initCanvas() {
  const canvasDom = document.createElement("canvas");
  const ctx = canvasDom.getContext("2d");
  canvas2dContext = ctx; // global variable assignment
  canvasDom.width = window.innerWidth;
  canvasDom.height = window.innerHeight;
  canvasDom.addEventListener("mousedown", handleMouseDown, false);
  document.body.appendChild(canvasDom);
}

function initColorPicker() {
  const colorPickerDom = document.getElementById("colorPicker");
  if (!colorPickerDom) return;
  colorPickerDom.addEventListener("input", (e) => {
    state.setPenColor(e.target.value);
  });
  colorPickerDom.value = state.penColor; // initialize color
}

function initLineWidthPicker() {
  const lineWidthPickerDom = document.getElementById("lineWidthPicker");
  if (!lineWidthPickerDom) return;
  lineWidthPickerDom.addEventListener("change", (e) => {
    state.setLineWidth(parseInt(e.target.value));
  });
  lineWidthPickerDom.value = state.lineWidth; // initialize picker value
}

function initClearButton() {
  const clearButtonDom = document.getElementById("clearButton");
  if (!clearButtonDom) return;
  clearButtonDom.addEventListener("click", clearAll, false);
}

function initEraserButton() {
  const eraserButtonDom = document.getElementById("eraserButton");
  if (!eraserButtonDom) return;
  eraserButtonDom.addEventListener("click", () => state.setEraser(), false);
}
function initPenButton() {
  const penButtonDom = document.getElementById("penButton");
  if (!penButtonDom) return;
  penButtonDom.addEventListener("click", () => state.setPen(), false);
}

function initStatusBar() {
  const statusBarDom = document.getElementById("statusBar");
  if (!statusBarDom) return;
  statusBarDom.innerText = state.getPenLabel();
}

function initUndoButton() {
  const undoButtonDom = document.getElementById("undoButton");
  if (!undoButtonDom) return;
  undoButtonDom.addEventListener("click", undo, false);
}

function initRedoButton() {
  const redoButtonDom = document.getElementById("redoButton");
  if (!redoButtonDom) return;
  redoButtonDom.addEventListener("click", redo, false);
}

function syncCanvasOptions(ctx, options) {
  const { penColor, lineCap, lineWidth } = options;
  ctx.strokeStyle = penColor;
  ctx.fillStyle = penColor;
  ctx.lineCap = lineCap;
  ctx.lineWidth = lineWidth;
}

function handleMouseDown(e) {
  const { clientX, clientY } = e;

  state.setMouseDownPos({
    x: clientX,
    y: clientY,
  });
  drawPoint(clientX, clientY);

  const canvasDom = canvas2dContext.canvas;
  canvasDom.addEventListener("mousemove", handleMouseMove, false);
  canvasDom.addEventListener("mouseup", handleMouseUp, false);
}

function handleMouseMove(e) {
  const { clientX: x2, clientY: y2 } = e;
  const { x: x1, y: y1 } = state.mouseDownPos;
  drawLine({ x1, y1, x2, y2 });
}

function handleMouseUp(_e) {
  const canvasDom = canvas2dContext.canvas;
  canvasDom.removeEventListener("mousemove", handleMouseMove, false);
  canvasDom.removeEventListener("mouseup", handleMouseUp, false);
}

function drawPoint(x, y) {
  state.createDrawRecord();
  state.setLastRecordMoveTo([x, y]);
  $drawPoint(x, y);
}

function drawLine({ x1, y1, x2, y2 }) {
  state.setLastRecordLineTo([x1, y1, x2, y2]);
  canvas2dContext.beginPath();
  canvas2dContext.moveTo(x1, y1);
  canvas2dContext.lineTo(x2, y2);
  canvas2dContext.stroke();
  state.setMouseDownPos({ x: x2, y: y2 });
}

function $drawPoint(x, y) {
  canvas2dContext.beginPath();
  canvas2dContext.arc(x, y, canvas2dContext.lineWidth / 2, 0, Math.PI * 2);
  canvas2dContext.fill();
}

function clearAll() {
  const canvasDom = canvas2dContext.canvas;
  canvas2dContext.clearRect(0, 0, canvasDom.width, canvasDom.height);
}

function drawLineBatch(lines) {
  canvas2dContext.beginPath();
  for (const line of lines) {
    const [x1, y1, x2, y2] = line;
    canvas2dContext.moveTo(x1, y1);
    canvas2dContext.lineTo(x2, y2);
  }
  canvas2dContext.stroke();
}

function redraw() {
  clearAll();
  for (const record of state.drawStack.items) {
    const { moveTo, lineTo, options } = record;
    // sync options for each record
    syncCanvasOptions(canvas2dContext, options);
    $drawPoint(moveTo[0], moveTo[1]);
    drawLineBatch(lineTo);
  }

  // restore current options
  syncCanvasOptions(canvas2dContext, state.getOptions());
}

function undo() {
  if (state.drawStack.isEmpty()) {
    console.log("drawStack is empty, cannot undo");
    return;
  }
  const record = state.drawStack.pop();
  state.undoStack.push(record);

  console.log("poped record:", record);
  console.log("drawStack:", state.drawStack.items);
  console.log("undoStack:", state.undoStack.items);
  redraw();
}

function redo() {
  if (state.undoStack.isEmpty()) {
    console.log("undoStack is empty, cannot redo");
    return;
  }
  const record = state.undoStack.pop();
  state.drawStack.push(record);

  console.log("poped record:", record);
  console.log("drawStack:", state.drawStack.items);
  console.log("undoStack:", state.undoStack.items);
  redraw();
}
```

```js [stack.js]
/**
 * æ ˆæ˜¯ä¸€ç§å—é™çš„çº¿æ€§æ•°æ®ç»“æ„,ç›¸è¾ƒäºæ•°ç»„æ¥è¯´åªèƒ½åè¿›å…ˆå‡º
 */
export default class Stack {
  items = [];

  /**
   * è·å–æ ˆçš„æ€»é•¿åº¦
   * @returns number
   */
  size() {
    return this.items.length;
  }

  /**
   * æ ˆæ˜¯å¦ä¸ºç©º
   * @returns boolean
   */
  isEmpty() {
    return this.size() === 0;
  }

  /**
   * å‡ºæ ˆ
   * @returns T | undefined
   */
  pop() {
    return this.items.pop();
  }

  /**
   * å…¥æ ˆ
   * @param item
   */
  push(item) {
    this.items.push(item);
  }

  /**
   * æŸ¥çœ‹æ ˆé¡¶å…ƒç´ (ä½†æ˜¯ä¸ä¼šæ‰§è¡Œå‡ºæ ˆæ“ä½œ)
   * @returns T | undefined
   */
  peek() {
    return this.items[this.items.length - 1];
  }

  /**
   * æ¸…æ ˆ
   */
  clear() {
    this.items = [];
  }

  /**
   * å­—ç¬¦ä¸²åºåˆ—åŒ–
   * @returns string
   */
  toString() {
    return "[" + this.items.toString() + "]";
  }
}
```

:::

### å®ç°æˆªå›¾åŠŸèƒ½

![screen-shot](https://raw.githubusercontent.com/liaohui5/images/main/images/202511221650195.png)

::: code-group

```js
/** @type {CanvasRenderingContext2D} */
let canvas2dContext;

const state = {
  // é€šè¿‡æ–‡ä»¶é€‰æ‹©æ¡†é€‰ä¸­çš„æ–‡ä»¶å¯¹åº”çš„å›¾ç‰‡å…ƒç´ 
  imageElement: null,
  width: 0,
  height: 0,
  setImageElement(dom) {
    this.width = dom.width;
    this.height = dom.height;
    this.imageElement = dom;
  },
  getImageElement() {
    return this.imageElement;
  },

  // è·å–å›¾ç‰‡å°ºå¯¸
  getImageSize() {
    const { width, height } = this;
    return { width, height };
  },

  // é¼ æ ‡æŒ‰ä¸‹æ—¶çš„åæ ‡
  canvasMouseDownPos: {
    x: 0,
    y: 0,
  },
  setCanvasMouseDownPos(x, y) {
    this.canvasMouseDownPos = {
      x,
      y,
    };
  },

  // æˆªå±é€‰å–åŒºåŸŸçš„åæ ‡
  screenShotPos: [0, 0, 0, 0],
  setScreenShotPos(data) {
    this.screenShotPos = data;
  },
  getScreenShotPos() {
    return this.screenShotPos;
  },
};

// init
window.onload = function init() {
  initFileInput();
};

function initFileInput() {
  const fileInputDom = document.getElementById("fileInput");
  fileInputDom.addEventListener("change", (e) => {
    loadImage(e.target.files[0]);
  });
}

function loadImage(file) {
  const url = URL.createObjectURL(file);
  const image = new Image();
  image.onload = function () {
    // å›¾ç‰‡åŠ è½½å®Œä¹‹å, å°†å›¾ç‰‡å…ƒç´ çš„ä¿¡æ¯ä¿å­˜åˆ° state
    // ç„¶ååˆå§‹åŒ– canvas, å°†å›¾ç‰‡/é®ç½©ç”»å‡ºæ¥
    // æœ€å revokeObjectURL
    state.setImageElement(image);
    initCanvas();
    drawImage();
    drawImageMask();
    URL.revokeObjectURL(url);
  };
  image.src = url;
}

function initCanvas() {
  const canvasDom = document.createElement("canvas");
  const ctx = canvasDom.getContext("2d");
  canvas2dContext = ctx;
  const { width, height } = state.getImageSize();
  canvasDom.width = width;
  canvasDom.height = height;
  canvas2dContext.canvas.addEventListener("mousedown", handleCanvasMouseDown, false);
  document.body.appendChild(canvasDom);
}

function drawImage() {
  const image = state.getImageElement();
  canvas2dContext.drawImage(image, 0, 0);
}

function drawImageMask(opacity = 0.5) {
  const { width, height } = canvas2dContext.canvas;
  canvas2dContext.fillStyle = `rgba(0,0,0,${opacity})`;
  canvas2dContext.fillRect(0, 0, width, height);
}

function handleCanvasMouseDown(e) {
  state.setCanvasMouseDownPos(e.offsetX, e.offsetY);
  canvas2dContext.canvas.addEventListener("mousemove", handleCanvasMouseMove, false);
}

function handleCanvasMouseMove(e) {
  canvas2dContext.canvas.addEventListener("mouseup", handleCanvasMouseUp, false);
  const { offsetX, offsetY } = e;
  const { x, y } = state.canvasMouseDownPos;
  const rectWidth = offsetX - x;
  const rectHeight = offsetY - y;
  const { width, height } = state.getImageSize();

  // ä¿å­˜æˆªå–åŒºåŸŸçš„4ä¸ªåæ ‡ x1,y1 x2,y2
  state.setScreenShotPos([x, y, rectWidth, rectHeight]);

  // æ¸…é™¤ç”»å¸ƒ
  canvas2dContext.clearRect(0, 0, width, height);

  // é‡æ–°ç»˜åˆ¶ mask å’Œ æˆªå–é€‰ä¸­éƒ¨åˆ†
  drawImageMask();
  drawScreenShot(rectWidth, rectHeight);
}

function handleCanvasMouseUp() {
  drawScreenShotImage();
  canvas2dContext.canvas.removeEventListener("mousedown", handleCanvasMouseDown, false);
  canvas2dContext.canvas.removeEventListener("mousemove", handleCanvasMouseMove, false);
}

function drawScreenShot(rectWidth, rectHeight) {
  // globalCompositeOperation docs:
  // https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // ä»…ä¿ç•™ç°æœ‰ç”»å¸ƒå†…å®¹å’Œæ–°å½¢çŠ¶ä¸é‡å çš„éƒ¨åˆ†
  canvas2dContext.globalCompositeOperation = "destination-out";
  canvas2dContext.fillStyle = "#000";

  const { x, y } = state.canvasMouseDownPos;
  canvas2dContext.fillRect(x, y, rectWidth, rectHeight);

  // åœ¨ç°æœ‰ç”»å¸ƒå†…å®¹çš„åé¢ç»˜åˆ¶æ–°çš„å›¾å½¢
  canvas2dContext.globalCompositeOperation = "destination-over";
  drawImage();
}

function drawScreenShotImage() {
  const screenShotPos = state.getScreenShotPos();
  const imageData = canvas2dContext.getImageData(...screenShotPos);
  const [_x1, _y1, w, h] = screenShotPos;
  createPreview(w, h, imageData);
}

function createPreview(width, height, imageData) {
  const canvasDom = document.createElement("canvas");
  canvasDom.width = width;
  canvasDom.height = height;
  const ctx = canvasDom.getContext("2d");
  ctx.putImageData(imageData, 0, 0);
  document.body.appendChild(canvasDom);
}
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div>
      <input type="file" id="fileInput" accept="image/*" />
    </div>
    <script type="module" src="./index.js"></script>
  </body>
</html>
```

:::

### åˆ®åˆ®ä¹åˆ®å¥–æ•ˆæœ

![guaguale](https://raw.githubusercontent.com/liaohui5/images/main/images/202511222141874.png)

å…¶å®å°±æ˜¯é»˜è®¤ç»™å…ƒç´ åŠ ä¸€ä¸ªé»˜è®¤çš„é®ç½©,ç„¶åå°†è®¾ç½® `globalCompositeOperation=destination-out`
é‚£ä¹ˆç”¨é¼ æ ‡åˆ’è¿‡çš„ä½ç½®å°±ä¼šé€æ˜, é‚£ä¹ˆåº•ä¸‹çš„å…ƒç´ å°±ä¼šå±•ç¤ºå‡ºæ¥, é‚£ä¹ˆå°±å¾—åˆ°äº†ç±»ä¼¼åˆ®å¥–çš„æ•ˆæœ

::: code-group

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
      .container {
        width: 400px;
        height: 200px;
        position: relative;
      }
      .container #mask,
      .container #anwser {
        position: absolute;
        top: 0;
        left: 0;
      }
      #anwser {
        z-index: 1;
      }
      #mask {
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="mask"></canvas>
      <canvas id="anwser"></canvas>
    </div>
    <script type="module" src="./index.js"></script>
  </body>
</html>
```

```js
// global states
const state = {
  width: 400,
  height: 200,
  isOpenable: false,
  setIsOpening(value) {
    this.isOpenable = value;
  },
};

function initAnwser() {
  const { width, height } = state;
  const anwserDom = document.getElementById("anwser");
  anwserDom.width = width;
  anwserDom.height = height;

  /** @type {CanvasRenderingContext2D} */
  const ctx = anwserDom.getContext("2d");
  const text = Math.random() > 0.5 ? "å†æ¥ä¸€ç“¶" : "è°¢è°¢æƒ é¡¾";
  ctx.fillStyle = "#f00";
  ctx.font = "32px 'å¾®è½¯é›…é»‘'";
  ctx.textAlign = "center";
  ctx.fillText(text, width / 2, height / 2);
}

function initMask() {
  const { width, height } = state;
  const maskDom = document.getElementById("mask");
  maskDom.width = width;
  maskDom.height = height;

  /** @type {CanvasRenderingContext2D} */
  const ctx = maskDom.getContext("2d");

  // draw mask
  ctx.fillStyle = "#ccc";
  ctx.fillRect(0, 0, 400, 200);

  // bind events
  maskDom.addEventListener("mousedown", () => {
    state.setIsOpening(true);
  });
  maskDom.addEventListener("mousemove", (e) => {
    if (!state.isOpenable) {
      return;
    }
    // è®¾ç½®è¿™ä¸ªå±æ€§å, åç»­ç”»çš„è·¯å¾„ä¼šè®©canvasé€æ˜
    ctx.globalCompositeOperation = "destination-out";

    const { offsetX, offsetY } = e;
    ctx.arc(offsetX, offsetY, 20, 0, Math.PI * 2);
    ctx.fill();
  });
  maskDom.addEventListener("mouseup", () => {
    state.setIsOpening(false);
  });
}

window.onload = function () {
  initAnwser();
  initMask();
};
```

:::

### å¼¹å¹•æ•ˆæœ

![danmu](https://raw.githubusercontent.com/liaohui5/images/main/images/202511230429478.png)

::: code-group

```html [index.html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Demo</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div class="container">
      <ul class="tool-bar">
        <li class="tool-bar-item">
          <span>å¼¹å¹•é¢œè‰²</span>
          <input type="color" id="danmu-color" value="#f8f8f8" />
        </li>
        <li class="tool-bar-item">
          <span>å­—ä½“å¤§å°</span>
          <input type="range" id="danmu-size" min="15" max="25" step="1" value="20" />
        </li>
        <li class="tool-bar-item">
          <span>å¼¹å¹•é€Ÿåº¦</span>
          <select id="danmu-speed">
            <option value="1">æ…¢</option>
            <option selected="selected" value="2">é»˜è®¤</option>
            <option value="4">å¿«</option>
          </select>
        </li>
        <li class="tool-bar-item">
          <input type="text" id="danmu-text" />
          <button id="send-danmu">å‘é€</button>
        </li>
      </ul>

      <div class="video-container">
        <video
          id="video"
          src="https://lf3-static.bytednsdoc.com/obj/eden-cn/nupenuvpxnuvo/xgplayer_doc/xgplayer-demo-720p.mp4"
          controls
        ></video>
      </div>
    </div>

    <script type="module" src="./index.js"></script>
  </body>
</html>
```

```css [styles.css]
* {
  margin: 0;
  padding: 0;
}
body {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
.container {
  padding: 20px;
  width: 1000px;
  margin: 0 auto;
}

.container .tool-bar {
  list-style: none;
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 15px 20px;
  margin-bottom: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 10px;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
  flex-wrap: wrap;
}

.container .tool-bar li.tool-bar-item {
  list-style: none;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  color: white;
  font-weight: 500;
}

.container .tool-bar span {
  font-size: 14px;
  min-width: 80px;
}

.container .tool-bar input[type="color"] {
  width: 40px;
  height: 40px;
  border: 2px solid white;
  border-radius: 6px;
  cursor: pointer;
  transition: transform 0.2s;
}

.container .tool-bar input[type="color"]:hover {
  transform: scale(1.1);
}

.container .tool-bar input[type="range"] {
  width: 120px;
  cursor: pointer;
  accent-color: #fff;
}

.container .tool-bar select,
.container .tool-bar input[type="text"],
.container .tool-bar button {
  padding: 8px 12px;
  border: 2px solid white;
  border-radius: 6px;
  font-size: 14px;
  background: rgba(255, 255, 255, 0.95);
  color: #333;
  cursor: pointer;
  transition: all 0.2s;
  font-weight: 500;
}

.container .tool-bar input[type="text"] {
  min-width: 150px;
}

.container .tool-bar select:hover,
.container .tool-bar input[type="text"]:hover {
  background: white;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.container .tool-bar button {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
  border: none;
  min-width: 80px;
}

.container .tool-bar button:hover {
  box-shadow: 0 6px 12px rgba(245, 87, 108, 0.4);
  transform: translateY(-2px);
}

.container .tool-bar button:active {
  transform: translateY(0);
}

.container #video {
  width: 100%;
  border: 1px solid #ccc;
}
```

```js [index.js]
import { createVideoDanmu } from "./VideoDanmu.js";

window.onload = function init() {
  const danmuColorDom = document.getElementById("danmu-color");
  const danmuSizeDom = document.getElementById("danmu-size");
  const danmuSpeedDom = document.getElementById("danmu-speed");
  const danmuTextDom = document.getElementById("danmu-text");
  const danmuSendDom = document.getElementById("send-danmu");
  const videoDom = document.getElementById("video");

  const videoDanmuInst = createVideoDanmu(videoDom);
  videoDanmuInst.loadData([
    {
      text: "æˆ‘å¤ªå–œæ¬¢è¿™é¦–æ­Œäº†",
      color: "#ff0000",
      fontSize: 20,
      speed: 2,
      showtime: 3,
    },
    {
      text: "ä½ ä»¬å¥½ä½ ä»¬å¥½ä½ ä»¬å¥½ä½ ä»¬å¥½ä½ ä»¬å¥½",
      color: "#00ff00",
      fontSize: 20,
      speed: 3,
      showtime: 6,
    },
    {
      text: "è¿™é¦–æ­Œå¾ˆå¥½å¬",
      color: "#ffffff",
      fontSize: 20,
      speed: 1,
      showtime: 7,
    },
    {
      text: "æˆ‘å¤ªå–œæ¬¢è¿™é¦–æ­Œäº†",
      color: "#ffffff",
      fontSize: 20,
      speed: 3,
      showtime: 8,
    },
    {
      text: "æˆ‘å¤ªå–œæ¬¢è¿™é¦–æ­Œäº†2",
      color: "#ff0000",
      fontSize: 20,
      speed: 4,
      showtime: 10,
    },
    {
      text: "ä½ ä»¬å¥½ä½ ä»¬å¥½ä½ ä»¬å¥½ä½ ä»¬å¥½ä½ ä»¬å¥½2",
      color: "#00ff00",
      fontSize: 20,
      speed: 3,
      showtime: 12,
    },
    {
      text: "è¿™é¦–æ­Œå¾ˆå¥½å¬222",
      color: "#ffffff",
      fontSize: 20,
      speed: 2,
      showtime: 14,
    },
    {
      text: "æˆ‘å¤ªå–œæ¬¢è¿™é¦–æ­Œäº†222",
      color: "#ffffff",
      fontSize: 20,
      speed: 2,
      showtime: 15,
    },
  ]);

  videoDom.addEventListener("play", () => videoDanmuInst.play(), false);
  videoDom.addEventListener("pause", () => videoDanmuInst.pause(), false);
  danmuSendDom.addEventListener("click", () => {
    const text = danmuTextDom.value.trim();
    if (text.length === 0) {
      console.log("è¯·è¾“å…¥å¼¹å¹•å†…å®¹");
      return;
    }
    if (text.length === 1) {
      console.log("ä¸èƒ½å‘é€å•ä¸ªå­—ç¬¦");
      return;
    }
    const color = danmuColorDom.value;
    const fontSize = parseInt(danmuSizeDom.value);
    const speed = parseInt(danmuSpeedDom.value);
    const showtime = videoDom.currentTime;
    const danmu = {
      color,
      fontSize,
      speed,
      text,
      showtime,
    };
    videoDanmuInst.loadData([danmu]);
    danmuTextDom.value = "";
  });
};
```

```js [VideoDanmu.js]
export class VideoDanmu {
  /** @type {CanvasRenderingContext2D} */
  canvasContext = null;

  // æ˜¯å¦æš‚åœå¼¹å¹•
  isPaused = true;

  // å¼¹å¹•æ± æ•°æ®
  danmuPool = [];

  // é»˜è®¤å¼¹å¹•æ ·å¼é…ç½®
  styleOptions = {
    text: "",
    color: "#ff0000",
    speed: 6,
    fontSize: 30,
    fontFamily: "Hack",
  };

  // å¯æ˜¾ç¤ºå¼¹å¹•çš„åŒºåŸŸä»½æ•°(æ€»è§†é¢‘é«˜åº¦ / 2 = å¯æ˜¾ç¤ºå¼¹å¹•é«˜åº¦)
  visibleAreaHeight = 2;

  constructor(videoDom, styleOpts = {}) {
    this.videoDom = videoDom;
    this.styleOptions = Object.assign(this.styleOptions, styleOpts);
    this.init();
    this.render();
  }

  init() {
    this.initConvas();
    this.initDom();
  }

  initConvas() {
    // ç”¨äºç»˜åˆ¶å¼¹å¹•
    const canvasDom = document.createElement("canvas");
    this.canvasContext = canvasDom.getContext("2d");

    // ç”¨äºè®¡ç®—å¼¹å¹•å®½åº¦ 4GTW: forGetTextWidth
    const canvasDom2 = document.createElement("canvas");
    this.canvasCtx4GTW = canvasDom2.getContext("2d");
  }

  initDom() {
    const container = document.createElement("div");
    const videoDom = this.videoDom;

    // container style
    container.style.position = "relative";
    container.width = videoDom.offsetWidth;
    container.height = videoDom.offsetHeight;

    // canvas style
    const canvasDom = this.canvasContext.canvas;
    canvasDom.width = videoDom.offsetWidth;
    canvasDom.height = videoDom.offsetHeight;
    canvasDom.style.position = "absolute";
    canvasDom.style.top = 0;
    canvasDom.style.left = 0;

    // append to dom tree
    const parentNode = videoDom.parentNode;
    container.append(canvasDom);
    container.append(videoDom);
    parentNode.append(container);
  }

  getVisibleAreaHeight() {
    return this.canvasContext.canvas.height / this.visibleAreaHeight;
  }

  setVisibleAreaHeight(n) {
    if (n < 1 || n > 5) {
      throw new Error("setVisibleAreaHeight: please give an number between 1 and 5");
    }
    this.visibleAreaHeight = n;
  }

  play() {
    this.isPaused = false;
    this.render();
  }

  pause() {
    this.isPaused = true;
  }

  loadData(data) {
    if (!Array.isArray(data)) {
      throw new Error("loadData: please give an array");
    }

    const danmus = data.map((item) => this.formatDanmu(item));
    this.danmuPool.push(...danmus);

    console.log("loadData:", danmus);
  }

  formatDanmu(item) {
    // {
    //   text: "",           // å¼¹å¹•å†…å®¹
    //   color: "#ff0000", // å¼¹å¹•é¢œè‰²
    //   speed: 2,           // å¼¹å¹•æ»šåŠ¨é€Ÿåº¦
    //   showtime: 8,        // å¼¹å¹•å±•ç¤ºæ—¶é—´
    //   fontSize: 20,       // å¼¹å¹•å­—ä½“å¤§å°
    //   fontFamily:'Hack',  // å¼¹å¹•å­—ä½“
    //   width:  ?           // å¼¹å¹•å®½åº¦
    //   x:      ?           // å¼¹å¹•èµ·å§‹ x åæ ‡
    //   y:      ?           // å¼¹å¹•èµ·å§‹ y åæ ‡
    //   isDone: false,      // æ˜¯å¦å·²ç»å±•ç¤ºè¿‡äº†
    // }
    const danmu = Object.assign({}, this.styleOptions, item);
    const { text, fontSize, fontFamily } = danmu;
    const danmuWidth = this.getDanmuWidth(text, fontSize, fontFamily);

    // è®¡ç®—èµ·å§‹ä½ç½®: é»˜è®¤åœ¨æœ€å³è¾¹
    // x: canvaså®½åº¦ + å¼¹å¹•æœ¬èº«çš„å®½åº¦
    // y: fontSize + canvaså¯æ˜¾ç¤ºå¼¹å¹•åŒºåŸŸéšæœº
    // å¼¹å¹•èµ·å§‹ä½ç½®æ”¾åœ¨ç”»å¸ƒå³ä¾§å¤–ï¼Œè¿™æ ·æ‰ä¼šä»å³å‘å·¦è¿›å…¥ç”»é¢
    const startX = this.canvasContext.canvas.width + danmuWidth;
    const startY = random(fontSize, this.getVisibleAreaHeight() - fontSize);

    return Object.assign(danmu, {
      isDone: false,
      width: danmuWidth,
      x: startX,
      y: startY,
    });
  }

  // è·å–å¼¹å¹•çš„å®½åº¦
  getDanmuWidth(text, fontSize, fontFamily) {
    this.canvasCtx4GTW.font = `${fontSize}px ${fontFamily}`;
    const { width } = this.canvasCtx4GTW.measureText(text);
    return width;
  }

  drawDanmu(danmu) {
    // åªæœ‰ è§†é¢‘çš„æ’­æ”¾æ—¶é—´å¤§äºç­‰äºå¼¹å¹•çš„å±•ç¤ºæ—¶é—´
    // æˆ–è€… å¼¹å¹•è¿˜æ²¡æœ‰å±•ç¤ºè¿‡, æ­¤æ—¶: æ‰ä¼šç»˜åˆ¶å¦åˆ™
    // ä¸€æ¬¡æ€§ç»˜åˆ¶å¤ªå¤šå¯èƒ½ä¼šå¯¼è‡´å¡é¡¿
    if (!danmu.isDone && this.videoDom.currentTime < danmu.showtime) {
      return;
    }

    // ç§»åŠ¨åæ ‡, ä¸åœå¾€å·¦ç§»åŠ¨
    danmu.x -= danmu.speed;

    // ç»˜åˆ¶
    const { text, color, fontSize, x, y } = danmu;
    const ctx = this.canvasContext;
    ctx.shadowColor = "#000000";
    ctx.shadowBlur = 2;
    ctx.font = `${fontSize}px '${danmu.fontFamily}'`;
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);

    // å¦‚æœå·²ç»ç§»åŠ¨åˆ°æœ€å·¦è¾¹äº†
    if (danmu.x <= -danmu.width) {
      danmu.isDone = true;
    }
  }

  renderDanmu() {
    const items = this.danmuPool;
    // console.log("renderDanmu count:", items.length);
    for (const danmu of items) {
      this.drawDanmu(danmu);
    }
  }

  removeDoneDanmu() {
    this.danmuPool = this.danmuPool.filter((item) => !item.isDone);
  }

  render() {
    this.clear();
    this.removeDoneDanmu();
    this.renderDanmu();
    !this.isPaused && requestAnimationFrame(() => this.render());
  }

  clear() {
    const { width, height } = this.canvasContext.canvas;
    this.canvasContext.clearRect(0, 0, width, height);
  }
}

/**
 * è¿”å›æŒ‡å®šèŒƒå›´å†…çš„éšæœºæ•°
 * @param min - æœ€å°å€¼
 * @param max - æœ€å¤§å€¼
 * @returns è¿”å›å€¼
 */
export function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

export const createVideoDanmu = (videoEl, options) => new VideoDanmu(videoEl, options);
```

:::

### äº”å­æ£‹æ¸¸æˆ

![five-chesses](https://raw.githubusercontent.com/liaohui5/images/main/images/20251126021404782.png)

::: code-group

```js [index.js]
window.addEventListener("DOMContentLoaded", () => {
  init();
});

/** @type {CanvasRenderingContext2D} */
let _canvas2dContext;
const setContext = (ctx) => {
  _canvas2dContext = ctx;
};
const getContext = () => _canvas2dContext;

// æ£‹å­çš„ç±»å‹
const CHESS_TYPE = {
  BLACK: {
    name: "é»‘æ£‹",
    color: "#000",
    value: 0,
  },
  WHITE: {
    name: "ç™½æ£‹",
    color: "#fff",
    value: 1,
  },
};

// å…¨å±€çš„çŠ¶æ€ç®¡ç†
const state = {
  width: 800, /////////// æ£‹ç›˜æ€»å®½åº¦
  height: 800, ////////// æ£‹ç›˜ä¸­é«˜åº¦
  columns: 15, ////////// æ£‹ç›˜åˆ—æ•°
  rows: 15, ///////////// æ£‹ç›˜è¡Œæ•°
  gridSize: 50, ///////// æ£‹ç›˜ç½‘æ ¼å¤§å°
  gridColor: "#f00", // æ£‹ç›˜ç½‘æ ¼é¢œè‰²
  chessRadius: 20, ////// æ£‹å­çš„åŠå¾„
  isBlack: true, //////// é»‘æ£‹å…ˆæ‰‹
  chessData: [], //////// æ£‹ç›˜ä¸Šçš„æ£‹å­æ•°æ®
  winChessCount: 5, ///// äº”å­æ£‹: å½“ç„¶æ˜¯è¿ç»­5ä¸ªç®—èµ¢
  switchPlayer() {
    state.isBlack = !state.isBlack;
  },
  getChess() {
    return this.isBlack ? CHESS_TYPE.BLACK : CHESS_TYPE.WHITE;
  },
  getChessName() {
    return this.getChess().name;
  },
  getChessColor() {
    return this.getChess().color;
  },
  getChessValue() {
    return this.getChess().value;
  },
  getChessData(rowIndex, colIndex) {
    return this.chessData[colIndex][rowIndex];
  },
  hasChessData(rowIndex, colIndex) {
    // åˆ¤æ–­æŸä¸ªä½ç½®æ˜¯å¦æœ‰æ£‹å­äº†, ä¸èƒ½é‡å¤ä¸‹æ£‹å­åˆ°åŒä¸€ä¸ªä½ç½®
    const value = this.getChessData(rowIndex, colIndex);
    return [CHESS_TYPE.BLACK.value, CHESS_TYPE.WHITE.value].includes(value);
  },
  putChessData(rowIndex, colIndex) {
    // ç»™æ£‹ç›˜æ•°æ®è®¾ç½®æ£‹å­æ•°æ®
    this.chessData[colIndex][rowIndex] = this.getChessValue();
    this.putChessCount += 1;
  },
};

function init() {
  initCanvasContext();
  drawGrids();
  initCanvasEvents();
  renderToDom(document.getElementById("app"));
}

function initCanvasContext() {
  const canvasDom = document.createElement("canvas");
  setContext(canvasDom.getContext("2d"));

  const { width, height } = state;
  canvasDom.width = width;
  canvasDom.height = height;
}

function drawGrids() {
  const ctx = getContext();
  const { columns, rows, gridSize, width, height, gridColor, chessData } = state;

  ctx.strokeStyle = gridColor;
  const endX = width - gridSize;
  for (let i = 1; i <= rows; i++) {
    const y = i * gridSize;
    ctx.moveTo(gridSize, y);
    ctx.lineTo(endX, y);
    ctx.stroke();
  }

  const endY = height - gridSize;
  for (let i = 1; i <= columns; i++) {
    const x = i * gridSize;
    ctx.moveTo(x, gridSize);
    ctx.lineTo(x, endY);
    ctx.stroke();
  }

  const chessDataCount = Math.max(columns, rows);
  for (let i = 0; i <= chessDataCount; i++) {
    chessData.push([]);
  }
}

// æ¸²æŸ“åˆ°é¡µé¢ä¸Š
function renderToDom(containerDOM) {
  createTipDom(containerDOM);
  const ctx = getContext();
  containerDOM.append(ctx.canvas);
  updateTipMsg();
}

// åˆ›å»ºæç¤ºä¿¡æ¯å…ƒç´ 
function createTipDom(containerDOM) {
  const tipDiv = document.createElement("div");
  tipDiv.id = "tip";
  containerDOM.append(tipDiv);
}

// æ›´æ–°æç¤ºä¿¡æ¯
function updateTipMsg() {
  const tipDiv = document.getElementById("tip");
  if (!tipDiv) return;
  tipDiv.textContent = `è¯· ${state.getChessName()} è½å­`;
}

// åˆå§‹åŒ– canvas äº¤äº’äº‹ä»¶
function initCanvasEvents() {
  const ctx = getContext();
  ctx.canvas.addEventListener("click", (e) => {
    const { gridSize } = state;
    const { offsetX, offsetY } = e;

    // åˆ¤æ–­å…¶å®æ˜¯å¦åœ¨æ£‹ç›˜ä¹‹å†…
    if (!isInBoard(offsetX, offsetY)) {
      console.log("è¯·åœ¨æ£‹ç›˜å†…ç‚¹å‡»", { offsetX, offsetY });
      return;
    }

    // è®©æ£‹å­ä¸‹åœ¨çº¿çš„äº¤æ±‡å¤„
    const rowIndex = getGridIndex(offsetX, gridSize);
    const colIndex = getGridIndex(offsetY, gridSize);
    const x = rowIndex * gridSize;
    const y = colIndex * gridSize;
    console.log({ x, y, rowIndex, colIndex });

    if (state.hasChessData(rowIndex, colIndex)) {
      alert("è¿™ä¸ªä½ç½®å·²ç»æœ‰æ£‹å­äº†!");
      return;
    }

    putChess(x, y, rowIndex, colIndex);
    if (isWin(rowIndex, colIndex)) {
      restartGame(`${state.getChessName()}å·²ç»èµ¢äº†!`);
      return;
    }
    state.switchPlayer();
    updateTipMsg();
  });
}

// åˆ¤æ–­å…¶å®æ˜¯å¦åœ¨æ£‹ç›˜ä¹‹å†…
function isInBoard(x, y) {
  const { width, height, gridSize } = state;
  const halfGridSize = gridSize / 2;
  const minX = halfGridSize;
  const minY = halfGridSize;
  const maxX = width - halfGridSize;
  const maxY = height - halfGridSize;
  return x > minX && x < maxX && y > minY && y < maxY;
}

// è®¡ç®—ç‚¹å‡»çš„æ˜¯ç¬¬å‡ ä¸ªæ ¼å­
function getGridIndex(pos, gridSize) {
  // å…¶å®å°±æ˜¯è¦å¾—åˆ°è·ç¦» v, æœ€è¿‘(gridSize)çš„å€æ•°æ•°å­—
  // v å°±æ˜¯ç‚¹å‡»çš„ä½ç½®(ä½†æ˜¯æœ‰å¯èƒ½ä¸æ˜¯ gridSize çš„å€æ•°æ•°å­—)
  // Math.floor((x + 25) / 50) * 50, è¿™æ ·å°±å¯ä»¥å¾—åˆ°
  // 50 çš„å€æ•°å¹¶å‘ä¸‹å–æ•´, +25æ˜¯å› ä¸ºæ˜¯å‘ä¸‹å–æ•´æ‰€ä»¥éœ€è¦åŠ ä¸ŠåŠ
  // ä¸ªæ ¼å­å®½åº¦, è¿™æ ·ç‚¹å‡»ä¸€ä¸ªæ ¼å­å³ä¾§çš„æ—¶å€™æ‰ä¼šå‡†ç¡®
  const halfGridSize = gridSize / 2;
  return Math.floor((pos + halfGridSize) / gridSize);
}

// æ”¾ç½®æ£‹å­
function putChess(x, y, rowIndex, colIndex) {
  drawChess(x, y);
  state.putChessData(rowIndex, colIndex);
}

// ç»˜åˆ¶æ£‹å­
function drawChess(x, y) {
  const ctx = getContext();
  ctx.beginPath();
  ctx.arc(x, y, state.chessRadius, 0, Math.PI * 2);
  ctx.fillStyle = state.getChessColor();
  ctx.fill();
  ctx.closePath();
}

// åˆ¤æ–­æ˜¯å¦å·²ç»èµ¢äº†:ä»»æ„ä¸€ä¸ªæ–¹å‘è¿ç»­æœ‰5ä¸ªæ£‹å­å°±ç®—èµ¢æ£‹äº†
function isWin(rowIndex, colIndex) {
  return (
    // ç«–å‘æŸ¥æ‰¾
    checkRows(rowIndex, colIndex) ||
    // æ¨ªå‘æŸ¥æ‰¾
    checkCols(rowIndex, colIndex) ||
    // å·¦ä¸Š -> å³ä¸‹ æŸ¥æ‰¾
    checkBackslash(rowIndex, colIndex) ||
    // å·¦ä¸‹ -> å³ä¸Š æŸ¥æ‰¾
    checkSlash(rowIndex, colIndex)
  );
}

// é€šç”¨çš„æ–¹å‘æ£€æŸ¥å‡½æ•°
function checkDirection({ rowIndex, colIndex, directions, limit }) {
  const targetChess = state.getChessValue();
  let lineChessCount = 1; // åœ¨ä¸€è¡Œçš„æ£‹å­ä¸ªæ•°

  // åˆå§‹åŒ–ä¸¤ä¸ªæ–¹å‘çš„æœç´¢ä¿¡æ¯
  const [dir1, dir2] = directions;
  const search1 = {
    rowIndex: rowIndex + dir1.rowIndex,
    colIndex: colIndex + dir1.colIndex,
    isNeed: true,
  };
  const search2 = {
    rowIndex: rowIndex + dir2.rowIndex,
    colIndex: colIndex + dir2.colIndex,
    isNeed: true,
  };

  let index = limit;
  while (index > 0) {
    if (lineChessCount === state.winChessCount) {
      return true;
    }

    // æ£€æŸ¥ç¬¬ä¸€ä¸ªæ–¹å‘
    if (
      search1.isNeed &&
      search1.rowIndex > 0 &&
      search1.rowIndex <= limit &&
      search1.colIndex > 0 &&
      search1.colIndex <= limit
    ) {
      const chess = state.getChessData(search1.rowIndex, search1.colIndex);
      if (chess === targetChess) {
        lineChessCount += 1;
        search1.rowIndex += dir1.rowIndex;
        search1.colIndex += dir1.colIndex;
      } else {
        search1.isNeed = false;
      }
    }

    // æ£€æŸ¥ç¬¬äºŒä¸ªæ–¹å‘
    if (
      search2.isNeed &&
      search2.rowIndex > 0 &&
      search2.rowIndex <= limit &&
      search2.colIndex > 0 &&
      search2.colIndex <= limit
    ) {
      const chess = state.getChessData(search2.rowIndex, search2.colIndex);
      if (chess === targetChess) {
        lineChessCount += 1;
        search2.rowIndex += dir2.rowIndex;
        search2.colIndex += dir2.colIndex;
      } else {
        search2.isNeed = false;
      }
    }

    index--;
  }
  return false;
}

// ç«–å‘æŸ¥æ‰¾æ˜¯å¦æœ‰5ä¸ªé¢œè‰²ç›¸åŒçš„æ£‹å­
function checkRows(rowIndex, colIndex) {
  return checkDirection({
    rowIndex,
    colIndex,
    directions: [
      { rowIndex: -1, colIndex: 0 }, // å‘ä¸Š
      { rowIndex: 1, colIndex: 0 }, // å‘ä¸‹
    ],
    limit: state.rows,
  });
}

// æ¨ªå‘æŸ¥æ‰¾æ˜¯å¦æœ‰5ä¸ªé¢œè‰²ç›¸åŒçš„æ£‹å­
function checkCols(rowIndex, colIndex) {
  return checkDirection({
    rowIndex,
    colIndex,
    directions: [
      { rowIndex: 0, colIndex: -1 }, // å‘å·¦
      { rowIndex: 0, colIndex: 1 }, // å‘å³
    ],
    limit: state.columns,
  });
}

// å·¦ä¸Š -> å³ä¸‹ æŸ¥æ‰¾(åæ–œçº¿)
function checkBackslash(rowIndex, colIndex) {
  return checkDirection({
    rowIndex,
    colIndex,
    directions: [
      { rowIndex: -1, colIndex: -1 }, // å·¦ä¸Š
      { rowIndex: 1, colIndex: 1 }, // å³ä¸‹
    ],
    limit: Math.max(state.columns, state.rows),
  });
}

// å·¦ä¸‹ -> å³ä¸Š æŸ¥æ‰¾(æ–œçº¿)
function checkSlash(rowIndex, colIndex) {
  return checkDirection({
    rowIndex,
    colIndex,
    directions: [
      { rowIndex: 1, colIndex: -1 }, // å·¦ä¸‹
      { rowIndex: -1, colIndex: 1 }, // å³ä¸Š
    ],
    limit: Math.max(state.columns, state.rows),
  });
}

// ä¸€æ–¹èƒœåˆ©, é‡å¯æ¸¸æˆ
function restartGame(message) {
  requestIdleCallback(() => {
    // å¼‚æ­¥å¼¹å‡ºé€šçŸ¥, è®©æ£‹å­å…ˆç”»å‡ºæ¥
    // å¦åˆ™è¿˜æ²¡æ¥å¾—åŠæ¸²æŸ“æ£‹å­å°±ç›´æ¥alertå¡ä½äº†
    window.alert(message);
    window.location.reload(true);
  });
}
```

```html [index.html]
<!doctype html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="no-referrer" />
    <link rel="stylesheet" href="./styles.css" />
    <title>title</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="./index.js"></script>
  </body>
</html>
```

```css [styles.css]
* {
  margin: 0;
  padding: 0;
}

#app {
  padding: 30px 0;
}

#app canvas {
  display: block;
  background: #ccc;
  margin: 0 auto;
}

#app #tip {
  margin-bottom: 20px;
  font-size: 18px;
  font-weight: bold;
  color: #f00;
  text-align: center;
}
```

:::
