## 枚举

```rust
// Rust 的枚举和其他语言的枚举不同,
// 每个可枚举字段不仅仅是一个固定的值,
// 它可以包含更多数据, 更像一个特殊的 struct
#[derive(Debug)]
enum Message {
    Quit,                       // 不关联任何数据
    Move {                      // 类似结构体的数据, 包含命名字段
        x: i32,
        y: i32,
    },
    Write(String),              // 包含一个字符串
    ChangeColor(i32, i32, i32), // 包含多个i32的数据
}

impl Message {
    // 可以给枚举定义方法
    fn f1(&self) {
        println!("f1 called");
    }
}

fn main() {
    let m1 = Message::Write(String::from("str"));
    m1.f1();

    let m2 = Message::Move { x: 1, y: 2 };
    dbg!(m2);
}
```

## match 模式匹配

- [Option](https://doc.rust-lang.org/std/option/enum.Option.html)
- [match](https://rustwiki.org/zh-CN/std/keyword.match.html)

Rust 的模式匹配非常像其他编程语言的 switch/case 语句

不同的是, match 语句必须要让值是穷尽的, 也就是说没有匹配到的情况也必须要加上

::: code-group

```rust [普通值匹配]
fn main() {
    let s = 11;

    match s {
        1 => println!("1"),
        // 一次匹配多个值, 类似
        // case 3:
        // case 5:
        // case 7:
        //    break;
        3|5|7 => println!("3,5,7,9"),

        // 匹配一个范围内的数字
        10..20 => println!("10-20"),
        _ => println!("unknown"),
    }
}
```

```rust [Option枚举匹配]
fn main() {
    // 使用标准库的 Option 枚举
    // let x: Option<i32> = None;
    let x: Option<i32> = Some(1);
    // let x: Option<i32> = Some(11);
    // let x: Option<i32> = Some(2);

    match x {
        // case None 的情况
        None => println!("x value is none"),
        // case 1 的情况
        Some(1) => {
            println!("x = 1");
        },
        // case 11 的情况
        Some(11) => {
            println!("x = 11");
        },
        // _ 代表 switch-case 最后那个 default
        // 当没有匹配到上面任何一个 case 的时候执行
        _ => println!("not matched"),
    }
}
```

```rust [自定义枚举匹配]
enum Season {
    Spring,
    Summer,
    Autumn,
    Winter,
}

fn main() {
    let s = Season::Summer;

    match s {
        Season::Spring => println!("春"),
        Season::Summer => println!("夏"),
        Season::Autumn => println!("秋"),
        Season::Winter => println!("冬"),
        _ => println!("unknown"),
    }
}
```

:::

## if let 简洁控制流

```rust
enum Season {
    Spring,
    Summer,
    Autumn,
    Winter,
}

fn main() {
    let x = 11;

    // 普通值可以这样判断
    if x == 11 {
        println!("if: x=11");
    }


    // 如果是个枚举, 就无法直接 if 判断, 以为类型不一样
    // 虽然可以用 match 来判断, 但是就一种情况, 感觉有些麻烦
    let s = Some(11);
    // match s {
    //     Some(11) => println!("match: x=11"),
    //     _ => (),
    // }

    // if let 的写法等同于上面的 match 写法
    // 这个表达式中的 = 不是赋值的意思
    // 注意必须 Some(xx) 在前, 要判断的值在后, 
    // 否则报错, 且判断有误, 就像这样, 也能进入 if
    // if let s = Some(15) {
    //     println!("if-let:x=15");
    // }
    if let Some(12) = s {
        println!("if-let:x=11");
    } else {
        println!("if-let: else");
    }

    // if let 也可以用于自定义枚举
    // 还可以多分支形式的判断
    let summer = Season::Summer;
    if let Season::Spring = summer {
        println!("Season::Spring");
    } else if let Season::Summer = summer {
        println!("Season::Summer");
    } else {
        println!("not Season::Summer");
    }
}
```
