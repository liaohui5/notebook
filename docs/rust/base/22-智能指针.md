## 什么是指针(pointer)

指针是一个宝航内存地址的变量的通用的概念,
学过C的都知道是怎么回事, 就不画图了, 在C的笔记中画过了

## 什么是智能指针(smtart pointers)

智能指针是一类数据结构, 他们的表现类似指针,
但是也拥有额外的元数据和功能

Rust 标准库中不同的智能指针提供了多于引用的额外功能, 本章将会探索的一个例子便是 引用计数
(reference counting)智能指针类型, 其允许数据有多个所有者, 引用计数智能指针记录总共有多少
个所有者, 并当没有任何所有者时负责清理数据

在 Rust 中, 普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针
相反, 在大部分情况下, 智能指针拥有它们指向的数据

标准库中最常用的一些智能指针:

- Box\<T\>: 用于在堆上分配数据
- Rc\<T\>: 一个引用计数类型, 他的数据可以有多个所有者
- Ref\<T\> 和 RefMut\<T\> 通过 RefCell\<T\> 来访问

另外可能会涉及 `内部可变性`(interior mutability)模式,
这是不可变类型暴露出改变其内部值的 API, 我们也会讨论
引用循环(reference cycles)会如何泄漏内存,以及如何避免

### 指针指针的特点:

1. 指针指向堆上分配内存空间(如: Box), 普通指针(如:&str) 是引用栈上的数据
2. 实现 Deref 和 Drop 特性

   1. Deref 自动解引用
   2. Drop 超出生命周期自动清理(类似垃圾回收机制)

## Box\<T\>

- Box\<T\> 是最简单的只能指针, 他允许你在堆内存中存储数据
- 没有额外的性能开销, 但是也没有额外的功能
- 实现了 `Deref` 和 `Drop` 特性(trait)

适用场景:

- 在编译时, 某个类型的大小无法确定, 但是使用该类型时, 上下文却需要知道他确切的大小
- 当有大量的数据, 想要移交所有权, 但需要确保在操作时数据不会被复制
- 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候

### 使用 Box 在堆上存储数据

```rust
fn main () {
    let n = Box::new(5); // 类似C语言的 malloc 函数
    println!("n = {}", n);
}
```

### 可以使用 Box 创建递归类型

比如创建一个单向链表 `LinkedList`

```rust
struct Node<T> {
  value: T,
  next: Option<Box<Node<T>>>
}
struct LinkedList<T> {
  head: Option<Box<Node<T>>>
}
```

## Deref 特性

通过实现 `Deref` 这个特性, 就能够重载`* 解引用运算` (de-reference operator),
注意, 这个 `*` 不是乘法的意思, 和 C 语言的解引用是一样的: `获取指针对应内存地址空间的值`

### 解引用获取指针(引用)的值

```rust
fn main () {
    let num = 5;
    let num_ref = &num; // 指针指向栈上的内存空间
                        // 用C表示: int* num_ref = &x;

    assert_eq!(num, 5); // 直接取值对比
    assert_eq!(*num_ref, 5); // 需要解引用, 获取到引用(指针)对应空间的值然后对比
}
```

### Box 也可以直接解引用

```rust
fn main() {
    let x = 15;
    let xbox_ref = Box::new(x);
    // Box::new 指针和上面的指针是不一样的, 堆内存上空间需要
    // 手动 malloc 分配, 手动 free 释放
    // 用 C 表示: int * xbox_ref = (int *)malloc(sizeof(int));

    assert_eq!(x, 15);
    assert_eq!(*xbox_ref, 15); // Box 智能指针也可以直接解引用获取值
}
```

### 自定义智能指针

手动实现一个 Box, 了解智能指针的原理

#### 初步实现

```rust
#[derive(Debug)]
struct MockBox<T>(T);

impl<T> MockBox<T> {
    fn new(value: T)-> Self {
        Self(value)
    }
}

fn main () {
    let y = 25;
    let mbox_ref = MockBox::new(y);
    assert_eq!(y, 25);
    assert_eq!(*mbox_ref, 25);// 编译器错误: type `MockBox<{integer}>` cannot be dereferenced
    // 默认情况下, 如果一个 struct 实例不是一个智能指针, 它就无法被直接解引用
    // 获取到内存中对应的值, 如果需要让这个 struct 变成一个智能指针(也就是可以直接解引用)
    // 那么就需要实现 std::ops::Deref 这个特性(也就是: trait)
}

```

#### 发现不能直接解引用, 需要实现 Deref 特性

- [std::ops::Deref 文档](https://doc.rust-lang.org/std/ops/trait.Deref.html)

```rust {1,12-18}
use std::ops::Deref;

#[derive(Debug)]
struct MockBox<T>(T);

impl<T> MockBox<T> {
    fn new(value: T)-> Self {
        Self(value)
    }
}

impl<T> Deref for MockBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

fn main () {
    let y = 25;
    let mbox_ref = MockBox::new(y);
    assert_eq!(y, 25);
    assert_eq!(*mbox_ref, 25);
    // 实现 std::ops::Deref 这个特性以后, 就可以像Box那样, 直接解引用
    // 那么换句话说, 我们就实现了一个自己的只能指针 MockBox, 功能和 Box 一样
}

```

### 函数/方法的隐式解引用转换

#### 什么是隐式解引用转换

英文: `deref coercions`

当将一个与函数定义的参数类型不匹配的指针(引用), 作为
参数传函数去调用, Rust 编译器会尝试: 自动将这个指针转换为一个与函数定义
的参数类型匹配的指针(引用), 这个过程就叫做: 隐式解引用转换(Deref Coercion)

1. 解引用转换是将一种类型(A)隐式的(也就是不用手动操作的)转换为另外一种类型(B)的引用
2. 因为 A 类型实现了 Deref trait, 并且其关联类型是 B 类型(意思是: A 解引用之后, 得到的数据类型是 B 类型)

比如: `解引用转换` 可以将 `&String` 转换为 `&str`,
因为类型 String 实现了 Deref trait 并且其关联类型是 &str
也就是说: `impl std::ops::Deref for String` 中实现的 deref 方法
返回的值是一个 &str 数据类型, [看文档验证下](https://rustwiki.org/zh-CN/std/string/struct.String.html#deref-methods-str)

#### 隐式解引用转换现象

```rust
fn say_hi(name: &str) {
    println!("Hi, {}!", name);
}

fn main () {
    let tom = "tom";
    let jack = String::from("jack");
    let jerry = Box::new(String::from("jerry"));

    say_hi(tom);    // 类型: &str
    say_hi(&jack);  // 类型: &String
    say_hi(&jerry); // 类型: &Box<String>
    // 为什么可以这样使用呢? 按照道理来说, 这应该类型不匹配才对啊
    // 这是因为: 传入的参数都被隐式地解引用转换类型了, 并不是传入
    // 什么类型, 函数就使用什么类型
}
```

#### 能够进行隐式解引用转换的条件

只有实现了 `std::ops::Deref 或 std::ops::DerefMut` 这两个特性的类型, 才能进行隐式解引用转换

#### 隐式解引用转换的规则

+ 一直调用 `deref` 方法(所以要求必须实现 `std::ops::Deref` 特性)直到类型正确
+ 如果到最后无法再调用 `deref` 方法, 那么就证明不能隐式转换为函数想要的类型

```rust
say_hi(tom); // 类型: &str, 不用转换类型

say_hi(&jack);  
// 传入类型: &String, 参数类型: &str
// 1. 调用 String deref => &str

say_hi(&jerry); 
// 传入类型: &Box<String>, 参数类型: &str
// 1. 先调用 Box deref => String
// 2. 再调用 String deref => &str
```

#### 解引用转换如何与可变性交互

上述代码传入的引用都是只读的, 如果有可变的引用, 如何进行 `deref` 解引用操作呢?

与 `std::ops::Deref` 类似的特性还有一个 [std::ops::DerefMut](https://rustwiki.org/zh-CN/std/ops/trait.DerefMut.html) 这个特性就是用于可变引用的


Rust编译器在发现类型和 trait 的实现满足以下任意一种情况时会进行解引用强制转换:

1. `T: Deref<Target=U>`    => `从 &T 转为 &U`
2. `T: DerefMut<Target=U>` => `从 &mut T 转为 &mut U`
3. `T: Deref<Target=U>`    => `从 &mut T 转为 &U`

## Drop 特性

这个特性可以实现类似其他编程语言 `垃圾回收` 的效果, 但是原理不一样, [查看文档](https://rustwiki.org/zh-CN/std/ops/trait.Drop.html)

编程语言的内存管理方式:

1. 垃圾回收: 需要一直运行一个程序, 来检查, 所使用的内存是否还需要使用, 不使用了就回收
2. Drop: 是 Rust 编译器, 在编译时就分析出代码运行结束的时候, 自动调用 `Drop` 特性
3. Rust 语言的 `Drop` 特性, 是 `Rust` 编译器在编译时, 自动调用的, 而不是 `运行时`

Rust 既不同于 C/C++ 手动管理释放内存, 也不同于 Go/Java/Python 自动垃圾回收内存,
而是通过编译器在编译时分析并决定, 变量需要何时释放内存, 并且将释放内存的代码自动注入到源代码里, 
然后再编译, 那么通过编译后的代码, 就能实现一种 `类似垃圾回收的效果`

由于, 手动释放内存可能会导致 `重复释放` 的问题(在C语言中很明显), 所以在 Rust 中
并不允许你手动调用这个特性的 drop 方法, 而是编译器会自动调用这个特性的 drop 方法

```rust
#[derive(Debug)]
struct TestDropTrait;

impl TestDropTrait {
    fn new() -> Self {
        TestDropTrait
    }
}

impl Drop for TestDropTrait {
    fn drop(&mut self) {
        println!("TestDropTrait::drop executed");
    }
}

fn main () {
    let tdt = TestDropTrait::new();
    println!("tdt created, {:?}", tdt);

    // tdt.drop();
    // 不能手动调用 drop, 会报错  explicit destructor calls not allowed
}

// 当 tdt 离开这个作用域后, 会自动的执行 drop 方法
// 也就是说, 程序执行完 main 方法后会输出: `TestDropTrait::drop executed`
```