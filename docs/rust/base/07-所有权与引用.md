## Rust 内存管理方式

1. 既不像C语言那样手动分配手动释放
2. 也不想GO/Java/Python/JS那样有垃圾回收机制

通过所有权系统管理内存, 编译器在编译时会根据一系列的规则进行检查

如果违反了任何这些规则, 程序都不能编译, 在运行时, 所有权系统的任何功能都不会减慢程序

简而言之, Rust 选择让程序员在写代码时候就遵循一定的规则, 然后让编译器来检查,
如果违法这些规则就无法通过编译, 这就导致, 所有代码都必须按照编译器的规则来写,
从而实现了, 类似垃圾回收的效果(但并不是真正的GC), 但是性能却高于有GC的语言

## 什么是所有权

`所有权(ownership)` 是 Rust 用于如何管理内存的一组规则

## 所有权规则

1. Rust 中每一个值都有一个所有者 `owner`
2. 值在任何时候都只有一个所有者
3. 当所有者(变量)离开作用域, 这个值就会被丢弃(内存被释放)

## 作用域

```rust
fn main() {
    let a = 10;
    { // {} 表达式可以创建单独的作用域

        // println!("b={b}");
        // 在变量声明之前,是无法访问的
        let b = a + 10;
        println!("inner: {b}");
    };

    // 此处(超出作用域范围)是无法访问到 b 这个变量的
    // 随着 {} 表达式执行完, 它也会被销毁
    // println!("outer: {b}");

    println!("outer: {a}");
}
```

## String 类型

```rust
fn main() {
    // String::from 返回字符串对象
    let mut str = String::from("hello");

    // 这需要动态分配内存大小
    str.push_str(" world");

    println!("s1 is: {str}");
}
```

## 内存与分配

因为不确定字符串到底需要多大的内存空间,
所以需要在运行时, 动态的分配内存空间,
学习过C语言的, 会非常容易理解这个概念,
[在笔记中也有一个c语言动态分配内存的例子](http://localhost:3333/clang/11-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D)

### 变量与数据的交互方式: 移动

这里直接用c语言代码对比,方便理解数据存储在哪

#### 确定数据宽度的数据

[推荐阅读](https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D)

::: code-group

```rust [rust]
fn main() {
  // 局部变量的赋值
  // 这样的确定数据宽度的局部变量肯定是放到栈区的
  let a: i8 = 5;
  let b: i8 = a;
  println!("a={a},b={b}");
}
```

```c [c]
#include <stdio>
int main() {
  // 局部变量是存放在栈区的,
  // 那么 Rust 的局部变量也类似
  int a = 1;
  int b = a;
  printf("a=%d, b=%d\n", a, b);
}
```

:::

#### 需要动态分配内存的数据

::: code-group

```rust
fn main() {
  let s1 = String::from("hello");
  let s2 = s1;

  // 此处是无法访问 s1 的, Rust 认为 s1 的
  // 所有权移交给了 s2, 那么 s1 就是没用的, 可丢弃的

  ///// 为什么如此设计?
  // A: 为了实现类似自动垃圾回收的的效果,
  // 1. 这种不确定数据宽度的数据肯定是存在堆区的
  // 2. 为了速度, 这个赋值操作肯定是拷贝指针而不是实际的内存数据
  // 3. 为了避免重复释放,内存泄漏等问题, s1 移交所有权后就立即销毁
  // 这也是所有权规则2: 值在任何时候都只有一个所有者
  println!("s2={s2}");
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
  // 1.初始化内存并赋值 let s1 = String::from("hello");
  char *s1 = (char *)malloc(sizeof(char) * 6); // hello\0
  if (s1 == NULL) {
    fprintf(stderr, "memory assign fail %s:%d\n", __FILE__, __LINE__);
    exit(1);
  }
  strcpy(s1, "hello");

  char *s2 = s1;
  /* let s2 = s1;
    在 Rust 中 s1移交所有权就立即释放掉
    相当于执行了这2个步骤:
    free(s1);
    s1 = NULL;
    所以 Rust 不允许你在移交所有权之后再次访问
  */

  // 输出s2内容
  printf("s2=%s\n", s2);

  // 最后代码执行完释放 s2
  free(s2);
  s2 = NULL;

  return 0;
}
```

:::

### 变量与数据的交互方式: 克隆

这个克隆肯定是针对堆区的数据来说的, 栈区的本来就是直接赋值, 并不是操作指针

::: code-group

```rust
fn main() {
  let s1 = String::from("hello");
  let s2 = s1.clone();

  // 注意了,这个是重新申请内存并填充数据,
  // 不是移交所有权, 和前面的 s2 = s1 有本质区别
  println!("s1={s1}, s2={s2}");
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
  // 初始化内存并赋值 let s1 = String::from("hello");
  char *s1 = (char *)malloc(sizeof(char) * 6); // hello\0
  if (s1 == NULL) {
    fprintf(stderr, "memory assign fail %s:%d\n", __FILE__, __LINE__);
    exit(1);
  }
  strcpy(s1, "hello");

  // 再申请一块内存存储数据
  char *s2 = (char *)malloc(sizeof(char) * 6);
  if (s1 == NULL) {
    fprintf(stderr, "memory assign fail %s:%d\n", __FILE__, __LINE__);
    exit(1);
  }
  // 将原来的数据复制过来
  memcpy(s2, s1, sizeof(char) * 6);

  // 所以 s1 并没有释放(移交所有权), 所以在后续可以访问
  // 输出内容
  printf("s1=%s,s2=%s\n", s1, s2);

  // 最后代码执行完释放 s1, s2
  free(s1);
  s1 = NULL;

  free(s2);
  s2 = NULL;
  return 0;
}
```

:::

## 所有权和函数

函数和之前的理论也是一样的, 栈和堆中的处理方式是不一样的

```c
fn copy_number(x: i32) -> i32{
    x
}

fn move_ownership(str: String)->String {
    str
}

fn main() {
    let a = 10;
    let b = copy_number(a); // 此时是复制栈中的数据
    println!("a={a},b={b}"); // 所以可以访问 a 和 b

    let s1 = String::from("hello");
    let s2 = move_ownership(s1); // 移交所有权给函数
    println!("s2={s2}"); // 所以此时可以访问s2, 但是无法访问s1
}
```

### 这并不方便

```rust
// 比如我需要这样一个函数: 获取字符串长度
// 我并不需要改变 str 的值, 返回值也只需要一个
// 然后后续还能照常访问 str, 在 Rust 中提供了
// 这样的功能, 将 str 的只读引用传入(借用)但是并没有移交所有权
fn get_str_len(str: String) -> (String, usize) {
    let len = str.len();
    (str, len)
}

fn main() {
    let s = String::from("hello");
    let (s, len) = get_str_len(s);
    println!("str = {s}");
    println!("len = {len}");
}
```

## 引用与借用

在之前的代码中, 我们想要将一个值传入函数中, 就会失去他的所有权,
但是有的时候这个很不方便, 如何将一个值传入函数, 但是不失去所有权?

### 借用

- 只读的引用叫借用

```rust
fn get_str_len(str: &String) -> usize {
    str.len()
}

fn main() {
    let s = String::from("hello");
    let len = get_str_len(&s); // 传入只读引用, 类似一个指针变量
    println!("str = {s}");
    println!("len = {len}");
}
```

### 引用

- 可修改的, 会移交所有权的叫引用, 且一个值同时只能存在一个可变引用

```rust
fn append_str(str: &mut String) -> &String {
    str.push_str("-append-string");
    str
}

fn main() {
    let mut s = String::from("hello");
    let s2 = append_str(&mut s);
    // println!("s = {s}"); // 此时无法访问s, 因为可变引用会移交所有权
    println!("s2 = {s2}");
}
```

### 为什么设计引用和借用

数据竞争会导致一些问题很难发现, 难以调试

为了避免数据竞争, 所有 Rust 让编译器在编译时就发现问题

如果我需要多个可变引用怎么办? 比如调用两次 `append_str`
此时就需要用到 {} 表达式创建作用域, 当离开作用域就会销毁

```rust
fn append_str(str: &mut String) -> &String {
    str.push_str("-append-string");
    str
}

fn main() {
    let mut s = String::from("hello");
    {
        append_str(&mut s);
    };

    // 此时上面{}中的&mut s随着作用域结束就会被丢弃
    // 那么就不会有所有权了, 此时再 &mut s 就没有问题
    let s2 = append_str(&mut s);

    // println!("s = {s}"); // 此时无法访问s, 因为可变引用会移交所有权
    println!("s2 = {s2}");
}
```

### 多个借用和可变引用

可以有多个只读引用但是不能同时有可变引用

```rust
fn main() {
    let mut s = String::from("hello");

    // 这样是没有问题的, 可以有多个只读的引用(借用)
    let r1 = &s;
    let r2 = &s;
    let r3 = &s;
    println!("r1={r1}");
    println!("r2={r2}");
    println!("r3={r3}");

    // 也可以用有一个可变的引用(引用)
    // 但是不能有多个可变的引用(在同一个作用域)
    let mr4 = &mut s;
    println!("mr4={mr4}");

    // 这样是没有问题的, 因为后续没有在访问 mr4 了
    let mr5 = &mut s;
    println!("mr5={mr5}");

    // println!("mr4={mr4}");
    // 不能再此处访问mr4,因为所有权已经被移交了
    // 也就是说, 当一个变量失去数据所有权之后就无法再访问数据了

/*
就好比我现在有一台电脑,
我借给别人用, 我还可以再要回来用, 因为所有权是我的(借用)
但是我买给别人, 我就无法再用了, 因为所有权不是我的(引用)
*/

}
```

### 悬垂引用

悬垂引用(Dangling References)和C语言中的悬垂指针是一样的道理

::: code-group

```rust [rust]
fn get_str() -> &String {
    let s = String::from("hello");
    &s
    // returns a reference to data owned by the current function
}

// 随着 get_str 的作用域结束,
// s 会被销毁, 内存会被释放
// 后续如果再那个这个指针去操作就会报错
// 所以编译器直接报错, 告诉你这样不对
// 让你无法通过编译
```

```c [c]
int* get_num() {
  int x = 10;

  // address of stack memory associated with local variable 'x' returned
  return &x;
}

// 随着 get_num 作用域结束, x会被销毁,
// 内存会被释放掉此时用取地址符去获取内
// 存地址是没有意义的
```

:::

## Rust 引用规则

- 在任何时间, 同一个作用域下, `要么只能有一个可变引用, 要么只能有多个不可变引用`

- 引用必须总是有效的, 不能出现悬垂指针
