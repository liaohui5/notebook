## 什么是引用计数智能指针?

引用计数智能指针英文: `reference counting smart pointer`

引用计数是指: 当一个对象被多个智能指针指向时, 这个对象被引用的次数

## 为什么有引用计数智能指针?

大多数情况下数据的所有权事非常明确的, 可以准确的知道那个变量拥有哪个数据的所有权, 但是有些情况, 数据的所有权并不明确, 需要多个变量共享数据的所有权, 这时就需要使用引用计数智能指针

比如: 一栋居民楼, 可以被多个业主共享, 但是这栋居民楼只有一个, 所以这栋居民楼的所有权是不明确的, 因为他不是某一个人的, 需要使用引用计数智能指针来管理

```rust
struct Building {
    name: String,
}

struct Owner {
    name: String,
    owned_house_id: u32,
    owned_house_in: Building,
}

impl Owner {
    pub fn new(name: &str, owned_house_id: u32, owned_house_in: Building) -> Self {
        Self {
            name: name.to_string(),
            owned_house_id,
            owned_house_in,
        }
    }
}


fn main() {
    let xfxq = Building {
        name: "幸福小区1栋".to_string(),
    };

    // 默认情况下: 这样做是不行的,
    // 创建 zs 的时候, xfxq 的所有权给了 zs 这个对象
    // 此时再创建 ls, 此时 ls 是没有所有权的
    let zs = Owner::new("zhang sang", 1101, xfxq);
    let ls = Owner::new("li si", 1201, xfxq);

    // 难道 一栋楼有一个人买了一套房子之后,其他的人就不能买房子了?
    // 这显然不太合理
}

```

## 使用引用计数智能指针共享数据

通过不可变引用, 可以在程序的不同部分之间共享只读的数据

```rust {10,14,32,39-41}
use std::rc::Rc;

struct Building {
    name: String,
}

struct Owner {
    name: String,
    owned_house_id: u32,
    owned_house_in: Rc<Building>,
}

impl Owner {
    pub fn new(name: &str, owned_house_id: u32, owned_house_in: Rc<Building>) -> Self {
         Self {
             name: name.to_string(),
             owned_house_id,
             owned_house_in,
         }
    }
}


fn show_house_info(o: Owner) {
    println!("{}{}室的业主是:{}",o.owned_house_in.name, o.owned_house_id, o.name);
}

fn main() {
    let xfxq = Building {
        name: String::from("幸福小区1栋")
    };
    let rc_xfxq = Rc::new(xfxq); // 使用引用计数智能指针

    // 此时并没有将 xfxq 的所有权给到 zs 对象
    // 而是传入了 rc_xfxq 克隆结果的所有权给了 zs ls ww 对象
    // xfxq 是真正存储数据的变量而 rc_xfxq 只是一个指针
    // 因此克隆一个指针速度是非常快的, 而且克隆指针的时候
    // 会让计数递增
    let zs = Owner::new("zhang sang", 1101, Rc::clone(&rc_xfxq));
    let ls = Owner::new("li si", 1201, Rc::clone(&rc_xfxq));
    let ww = Owner::new("wang wu", 1501, Rc::clone(&rc_xfxq));

    // 此时可以通过 引用计数指针 来获取现在有多少个引用
    // 4: 因为 Rc::new 就算一个, 后续每次 clone 会让数字递增1
    println!("{}现在有{}个业主", rc_xfxq.name, Rc::strong_count(&rc_xfxq));

    show_house_info(zs);
    show_house_info(ls);
    show_house_info(ww);
}
```
