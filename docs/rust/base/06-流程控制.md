---
outline: deep
---

## 分支结构

### 基础的多分支

与C系语言不同的是, if 的条件判断语句不需要 `()`

```rust
fn main() {
    let os_name = "macOS";

    if os_name == "Windows" {
        println!("Windows");
    } else if os_name == "macOS" {
        println!("macOS");
    } else if os_name == "Linux" {
        println!("Linux");
    } else {
        println!("Unknown");
    }
}
```

### 从分支返回结果

与C系语言大不同的来了, `面向表达式编程`, 可以很方便接收表达式的结果

```rust
fn main() {
    let os_name = "macOS";

    // 类似3元表达式, 但是确是使用 if else
    let is_mac = if os_name == "macOs" { "yes" } else { "no" };

    println!("is macOS:{}", is_mac);
}
```

## 循环结构

### while

::: code-group

```rust [普通循环]
fn main() {
    let mut i = 0;
    while i < 5 {
        println!("i={i}");
        i += 1;
    }
}
```

```rust [从表达式返回值]
fn main() {
    let avg = {
        let mut i = 0;
        let mut sum = 0;
        while i < 5 {
            println!("i = {i}");
            sum += i;
            i += 1;
            // 注: 在rust中没有 ++ 这操作符号
            // 所以不能 i++ 和 ++i 操作
        }

        // 创建{}表达式, 最后一句将结果返回
        sum / i
    };

    // 看起来好像没有必要, 不使用 {} 表达式
    // 也可以直接拿到值, 这个代码为了演示可以这样操作
    println!("avg = {avg}");
}
```

:::

### for in

```rust [普通循环]
fn main() {
    // .. 操作符类似python的 range 函数
    // 1.创建一个列表
    // 2.包含开始(0),但是不包含结尾(5)
    for item in (0..5) {
        println!("item={item}");
    }
}
```

### loop

```rust
fn main() {
    let mut i = 0;
    loop {
        // 默认就是无限循环, 只有使用 break 才会跳出循环
        i += 1;
        if i >= 5 {
            break;
        }
    }
    println!("sum");
}
```

## 练习

### 实现相互转换摄氏与华氏温度函数

```rust
fn celsius_to_fahrenheit(celsius: i32) -> i32 {
     (celsius * 9/5) + 32
}

fn fahrenheit_to_celsius (fahrenheit: i32) -> i32 {
    (fahrenheit - 32) * 5 / 9
}

fn main() {
    let fa = celsius_to_fahrenheit(30);
    println!("fahrenheit = {fa}");

    let ce = fahrenheit_to_celsius(30);
    println!("celsius = {ce}");
}
```

### 生成第 n 个斐波那契数

```rust
fn fib(n: i32) -> i32 {
    if n < 1 {
        return n;
    }

    let mut i = 0;
    let mut a = 0;
    let mut b = 1;
    while i < n {
        let temp = a; // start from 0
        a = b;        // prev loop b value
        b += temp;    // curr loop b value
        i += 1;
    }
    a
}

fn main() {
    let x = fib(6);
    println!("x = {x}");
}
```
